{"resolvedId":"D:/Files/Github/thaler/examples/solidstart/node_modules/.vite/deps/seroval.js?v=05cb9ea0","transforms":[{"name":"vite:optimized-deps","result":"// ../../node_modules/.pnpm/seroval@0.7.0/node_modules/seroval/dist/esm/development/index.mjs\nvar Feature = ((Feature2) => {\n  Feature2[Feature2[\"AggregateError\"] = 1] = \"AggregateError\";\n  Feature2[Feature2[\"ArrayPrototypeValues\"] = 2] = \"ArrayPrototypeValues\";\n  Feature2[Feature2[\"ArrowFunction\"] = 4] = \"ArrowFunction\";\n  Feature2[Feature2[\"BigInt\"] = 8] = \"BigInt\";\n  Feature2[Feature2[\"ErrorPrototypeStack\"] = 16] = \"ErrorPrototypeStack\";\n  Feature2[Feature2[\"Map\"] = 32] = \"Map\";\n  Feature2[Feature2[\"MethodShorthand\"] = 64] = \"MethodShorthand\";\n  Feature2[Feature2[\"ObjectAssign\"] = 128] = \"ObjectAssign\";\n  Feature2[Feature2[\"Promise\"] = 256] = \"Promise\";\n  Feature2[Feature2[\"Set\"] = 512] = \"Set\";\n  Feature2[Feature2[\"Symbol\"] = 1024] = \"Symbol\";\n  Feature2[Feature2[\"TypedArray\"] = 2048] = \"TypedArray\";\n  Feature2[Feature2[\"BigIntTypedArray\"] = 4096] = \"BigIntTypedArray\";\n  Feature2[Feature2[\"WebAPI\"] = 8192] = \"WebAPI\";\n  return Feature2;\n})(Feature || {});\nvar ALL_ENABLED = 16383;\nvar REF_START_CHARS = \"hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_\";\nvar REF_START_CHARS_LEN = REF_START_CHARS.length;\nvar REF_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_\";\nvar REF_CHARS_LEN = REF_CHARS.length;\nfunction getIdentifier(index) {\n  let mod = index % REF_START_CHARS_LEN;\n  let ref = REF_START_CHARS[mod];\n  index = (index - mod) / REF_START_CHARS_LEN;\n  while (index > 0) {\n    mod = index % REF_CHARS_LEN;\n    ref += REF_CHARS[mod];\n    index = (index - mod) / REF_CHARS_LEN;\n  }\n  return ref;\n}\nvar DEFAULT_OPTIONS = {\n  disabledFeatures: 0\n};\nfunction createParserContext(options = {}) {\n  const result = Object.assign({}, DEFAULT_OPTIONS, options || {});\n  return {\n    markedRefs: /* @__PURE__ */ new Set(),\n    refs: /* @__PURE__ */ new Map(),\n    features: ALL_ENABLED ^ result.disabledFeatures\n  };\n}\nfunction createSerializationContext(options) {\n  return {\n    stack: [],\n    vars: [],\n    assignments: [],\n    validRefs: [],\n    refSize: 0,\n    features: options.features,\n    markedRefs: new Set(options.markedRefs),\n    valueMap: /* @__PURE__ */ new Map()\n  };\n}\nfunction markRef(ctx, current) {\n  ctx.markedRefs.add(current);\n}\nfunction getRefParam(ctx, index) {\n  let actualIndex = ctx.validRefs[index];\n  if (actualIndex == null) {\n    actualIndex = ctx.refSize++;\n    ctx.validRefs[index] = actualIndex;\n  }\n  let identifier = ctx.vars[actualIndex];\n  if (identifier == null) {\n    identifier = getIdentifier(actualIndex);\n    ctx.vars[actualIndex] = identifier;\n  }\n  return identifier;\n}\nfunction getRootID(ctx, current) {\n  const ref = ctx.refs.get(current);\n  if (ref == null) {\n    return ctx.refs.size;\n  }\n  return ref;\n}\nfunction createIndexedValue(ctx, current) {\n  const ref = ctx.refs.get(current);\n  if (ref == null) {\n    const id = ctx.refs.size;\n    ctx.refs.set(current, id);\n    return id;\n  }\n  markRef(ctx, ref);\n  return ref;\n}\nfunction assert(cond, error) {\n  if (!cond) {\n    throw new Error(error);\n  }\n}\nfunction serializeChar(str) {\n  switch (str) {\n    case '\"':\n      return '\\\\\"';\n    case \"\\\\\":\n      return \"\\\\\\\\\";\n    case \"\\n\":\n      return \"\\\\n\";\n    case \"\\r\":\n      return \"\\\\r\";\n    case \"\\b\":\n      return \"\\\\b\";\n    case \"\t\":\n      return \"\\\\t\";\n    case \"\\f\":\n      return \"\\\\f\";\n    case \"<\":\n      return \"\\\\x3C\";\n    case \"\\u2028\":\n      return \"\\\\u2028\";\n    case \"\\u2029\":\n      return \"\\\\u2029\";\n    default:\n      return void 0;\n  }\n}\nfunction serializeString(str) {\n  let result = \"\";\n  let lastPos = 0;\n  let replacement;\n  for (let i = 0, len = str.length; i < len; i++) {\n    replacement = serializeChar(str[i]);\n    if (replacement) {\n      result += str.slice(lastPos, i) + replacement;\n      lastPos = i + 1;\n    }\n  }\n  if (lastPos === 0) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n  return result;\n}\nfunction deserializeString(str) {\n  return str.replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, \"\\\\\").replace(/\\\\n/g, \"\\n\").replace(/\\\\r/g, \"\\r\").replace(/\\\\b/g, \"\\b\").replace(/\\\\t/g, \"\t\").replace(/\\\\f/g, \"\\f\").replace(/\\\\x3C/g, \"<\").replace(/\\\\u2028/g, \"\\u2028\").replace(/\\\\u2029/g, \"\\u2029\");\n}\nvar REFERENCE = /* @__PURE__ */ new Map();\nvar INV_REFERENCE = /* @__PURE__ */ new Map();\nfunction createReference(id, value) {\n  REFERENCE.set(value, id);\n  INV_REFERENCE.set(id, value);\n  return value;\n}\nfunction hasReferenceID(value) {\n  return REFERENCE.has(value);\n}\nfunction hasReference(id) {\n  return INV_REFERENCE.has(id);\n}\nfunction getReferenceID(value) {\n  assert(hasReferenceID(value), \"Missing reference id\");\n  return REFERENCE.get(value);\n}\nfunction getReference(id) {\n  assert(hasReference(id), \"Missing reference for id:\" + id);\n  return INV_REFERENCE.get(id);\n}\nvar GLOBAL_KEY = \"__SEROVAL__\";\nif (typeof globalThis !== void 0) {\n  Object.defineProperty(globalThis, GLOBAL_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n} else if (typeof window !== void 0) {\n  Object.defineProperty(window, GLOBAL_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n} else if (typeof self !== void 0) {\n  Object.defineProperty(self, GLOBAL_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n} else if (typeof global !== void 0) {\n  Object.defineProperty(global, GLOBAL_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n}\nvar SYMBOL_STRING = {\n  [\n    0\n    /* AsyncIterator */\n  ]: \"Symbol.asyncIterator\",\n  [\n    1\n    /* HasInstance */\n  ]: \"Symbol.hasInstance\",\n  [\n    2\n    /* IsConcatSpreadable */\n  ]: \"Symbol.isConcatSpreadable\",\n  [\n    3\n    /* Iterator */\n  ]: \"Symbol.iterator\",\n  [\n    4\n    /* Match */\n  ]: \"Symbol.match\",\n  [\n    5\n    /* MatchAll */\n  ]: \"Symbol.matchAll\",\n  [\n    6\n    /* Replace */\n  ]: \"Symbol.replace\",\n  [\n    7\n    /* Search */\n  ]: \"Symbol.search\",\n  [\n    8\n    /* Species */\n  ]: \"Symbol.species\",\n  [\n    9\n    /* Split */\n  ]: \"Symbol.split\",\n  [\n    10\n    /* ToPrimitive */\n  ]: \"Symbol.toPrimitive\",\n  [\n    11\n    /* ToStringTag */\n  ]: \"Symbol.toStringTag\",\n  [\n    12\n    /* Unscopables */\n  ]: \"Symbol.unscopables\"\n};\nvar INV_SYMBOL_REF = {\n  [Symbol.asyncIterator]: 0,\n  [Symbol.hasInstance]: 1,\n  [Symbol.isConcatSpreadable]: 2,\n  [Symbol.iterator]: 3,\n  [Symbol.match]: 4,\n  [Symbol.matchAll]: 5,\n  [Symbol.replace]: 6,\n  [Symbol.search]: 7,\n  [Symbol.species]: 8,\n  [Symbol.split]: 9,\n  [Symbol.toPrimitive]: 10,\n  [Symbol.toStringTag]: 11,\n  [Symbol.unscopables]: 12\n  /* Unscopables */\n};\nvar SYMBOL_REF = {\n  [\n    0\n    /* AsyncIterator */\n  ]: Symbol.asyncIterator,\n  [\n    1\n    /* HasInstance */\n  ]: Symbol.hasInstance,\n  [\n    2\n    /* IsConcatSpreadable */\n  ]: Symbol.isConcatSpreadable,\n  [\n    3\n    /* Iterator */\n  ]: Symbol.iterator,\n  [\n    4\n    /* Match */\n  ]: Symbol.match,\n  [\n    5\n    /* MatchAll */\n  ]: Symbol.matchAll,\n  [\n    6\n    /* Replace */\n  ]: Symbol.replace,\n  [\n    7\n    /* Search */\n  ]: Symbol.search,\n  [\n    8\n    /* Species */\n  ]: Symbol.species,\n  [\n    9\n    /* Split */\n  ]: Symbol.split,\n  [\n    10\n    /* ToPrimitive */\n  ]: Symbol.toPrimitive,\n  [\n    11\n    /* ToStringTag */\n  ]: Symbol.toStringTag,\n  [\n    12\n    /* Unscopables */\n  ]: Symbol.unscopables\n};\nvar TRUE_NODE = {\n  t: 2,\n  i: void 0,\n  s: true,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar FALSE_NODE = {\n  t: 2,\n  i: void 0,\n  s: false,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar UNDEFINED_NODE = {\n  t: 4,\n  i: void 0,\n  s: void 0,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar NULL_NODE = {\n  t: 3,\n  i: void 0,\n  s: void 0,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar NEG_ZERO_NODE = {\n  t: 5,\n  i: void 0,\n  s: void 0,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar INFINITY_NODE = {\n  t: 6,\n  i: void 0,\n  s: void 0,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar NEG_INFINITY_NODE = {\n  t: 7,\n  i: void 0,\n  s: void 0,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar NAN_NODE = {\n  t: 8,\n  i: void 0,\n  s: void 0,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nfunction createNumberNode(value) {\n  return {\n    t: 0,\n    i: void 0,\n    s: value,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createStringNode(value) {\n  return {\n    t: 1,\n    i: void 0,\n    s: serializeString(value),\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createBigIntNode(ctx, current) {\n  assert(ctx.features & 8, 'Unsupported type \"BigInt\"');\n  return {\n    t: 9,\n    i: void 0,\n    s: \"\" + current,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createIndexedValueNode(id) {\n  return {\n    t: 10,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createDateNode(id, current) {\n  return {\n    t: 11,\n    i: id,\n    s: current.toISOString(),\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    f: void 0,\n    a: void 0,\n    b: void 0\n  };\n}\nfunction createRegExpNode(id, current) {\n  return {\n    t: 12,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: current.source,\n    m: current.flags,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createArrayBufferNode(id, current) {\n  const bytes = new Uint8Array(current);\n  const len = bytes.length;\n  const values = new Array(len);\n  for (let i = 0; i < len; i++) {\n    values[i] = bytes[i];\n  }\n  return {\n    t: 28,\n    i: id,\n    s: values,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction serializeArrayBuffer(ctx, current) {\n  const id = createIndexedValue(ctx, current);\n  if (ctx.markedRefs.has(id)) {\n    return createIndexedValueNode(id);\n  }\n  return createArrayBufferNode(id, current);\n}\nfunction createTypedArrayNode(ctx, id, current) {\n  const constructor = current.constructor.name;\n  assert(ctx.features & 2048, `Unsupported value type \"${constructor}\"`);\n  return {\n    t: 22,\n    i: id,\n    s: void 0,\n    l: current.length,\n    c: constructor,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: serializeArrayBuffer(ctx, current.buffer),\n    b: current.byteOffset\n  };\n}\nvar BIGINT_FLAG = 4096 | 8;\nfunction createBigIntTypedArrayNode(ctx, id, current) {\n  const constructor = current.constructor.name;\n  assert(\n    (ctx.features & BIGINT_FLAG) === BIGINT_FLAG,\n    `Unsupported value type \"${constructor}\"`\n  );\n  return {\n    t: 23,\n    i: id,\n    s: void 0,\n    l: current.length,\n    c: constructor,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: serializeArrayBuffer(ctx, current.buffer),\n    b: current.byteOffset\n  };\n}\nfunction createWKSymbolNode(ctx, current) {\n  assert(ctx.features & 1024, 'Unsupported type \"symbol\"');\n  assert(current in INV_SYMBOL_REF, \"seroval only supports well-known symbols\");\n  return {\n    t: 24,\n    i: void 0,\n    s: INV_SYMBOL_REF[current],\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createReferenceNode(id, ref) {\n  return {\n    t: 27,\n    i: id,\n    s: serializeString(getReferenceID(ref)),\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createDataViewNode(ctx, id, current) {\n  return {\n    t: 29,\n    i: id,\n    s: void 0,\n    l: current.byteLength,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: serializeArrayBuffer(ctx, current.buffer),\n    b: current.byteOffset\n  };\n}\nfunction getErrorConstructorName(error) {\n  if (error instanceof EvalError) {\n    return \"EvalError\";\n  }\n  if (error instanceof RangeError) {\n    return \"RangeError\";\n  }\n  if (error instanceof ReferenceError) {\n    return \"ReferenceError\";\n  }\n  if (error instanceof SyntaxError) {\n    return \"SyntaxError\";\n  }\n  if (error instanceof TypeError) {\n    return \"TypeError\";\n  }\n  if (error instanceof URIError) {\n    return \"URIError\";\n  }\n  return \"Error\";\n}\nfunction getErrorConstructor(errorName) {\n  switch (errorName) {\n    case \"Error\":\n      return Error;\n    case \"EvalError\":\n      return EvalError;\n    case \"RangeError\":\n      return RangeError;\n    case \"ReferenceError\":\n      return ReferenceError;\n    case \"SyntaxError\":\n      return SyntaxError;\n    case \"TypeError\":\n      return TypeError;\n    case \"URIError\":\n      return URIError;\n    default:\n      throw new Error(`Unknown Error constructor \"${errorName}\"`);\n  }\n}\nfunction getErrorOptions(ctx, error) {\n  let options;\n  const constructor = getErrorConstructorName(error);\n  if (error.name !== constructor) {\n    options = { name: error.name };\n  } else if (error.constructor.name !== constructor) {\n    options = { name: error.constructor.name };\n  }\n  const names = Object.getOwnPropertyNames(error);\n  for (const name of names) {\n    if (name !== \"name\" && name !== \"message\") {\n      if (name === \"stack\") {\n        if (ctx.features & 16) {\n          options = options || {};\n          options[name] = error[name];\n        }\n      } else {\n        options = options || {};\n        options[name] = error[name];\n      }\n    }\n  }\n  return options;\n}\nfunction getIterableOptions(obj) {\n  const names = Object.getOwnPropertyNames(obj);\n  if (names.length) {\n    const options = {};\n    for (const name of names) {\n      options[name] = obj[name];\n    }\n    return options;\n  }\n  return void 0;\n}\nfunction isIterable(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return false;\n  }\n  switch (value.constructor) {\n    case Map:\n    case Set:\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n    case BigInt64Array:\n    case BigUint64Array:\n      return false;\n    default:\n      break;\n  }\n  return Symbol.iterator in value;\n}\nfunction getTypedArrayConstructor(name) {\n  switch (name) {\n    case \"Int8Array\":\n      return Int8Array;\n    case \"Int16Array\":\n      return Int16Array;\n    case \"Int32Array\":\n      return Int32Array;\n    case \"Uint8Array\":\n      return Uint8Array;\n    case \"Uint16Array\":\n      return Uint16Array;\n    case \"Uint32Array\":\n      return Uint32Array;\n    case \"Uint8ClampedArray\":\n      return Uint8ClampedArray;\n    case \"Float32Array\":\n      return Float32Array;\n    case \"Float64Array\":\n      return Float64Array;\n    case \"BigInt64Array\":\n      return BigInt64Array;\n    case \"BigUint64Array\":\n      return BigUint64Array;\n    default:\n      throw new Error(`Unknown TypedArray \"${name}\"`);\n  }\n}\nvar IDENTIFIER_CHECK = /^[$A-Z_][0-9A-Z_$]*$/i;\nfunction isValidIdentifier(name) {\n  const char = name[0];\n  return (char === \"$\" || char === \"_\" || char >= \"A\" && char <= \"Z\" || char >= \"a\" && char <= \"z\") && IDENTIFIER_CHECK.test(name);\n}\nfunction createURLNode(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"URL\"');\n  return {\n    t: 25,\n    i: id,\n    s: serializeString(current.href),\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    f: void 0,\n    a: void 0,\n    b: void 0\n  };\n}\nfunction createURLSearchParamsNode(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"URLSearchParams\"');\n  return {\n    t: 26,\n    i: id,\n    s: serializeString(current.toString()),\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    f: void 0,\n    a: void 0,\n    b: void 0\n  };\n}\nasync function createBlobNode(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"Blob\"');\n  return {\n    t: 30,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: serializeString(current.type),\n    m: void 0,\n    d: void 0,\n    f: serializeArrayBuffer(ctx, await current.arrayBuffer()),\n    a: void 0,\n    b: void 0\n  };\n}\nasync function createFileNode(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"File\"');\n  return {\n    t: 31,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: serializeString(current.type),\n    m: serializeString(current.name),\n    d: void 0,\n    f: serializeArrayBuffer(ctx, await current.arrayBuffer()),\n    a: void 0,\n    b: current.lastModified\n  };\n}\nasync function generateNodeList(ctx, current) {\n  const size = current.length;\n  const nodes = new Array(size);\n  const deferred = new Array(size);\n  let item;\n  for (let i = 0; i < size; i++) {\n    if (i in current) {\n      item = current[i];\n      if (isIterable(item)) {\n        deferred[i] = item;\n      } else {\n        nodes[i] = await parse(ctx, item);\n      }\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    if (i in deferred) {\n      nodes[i] = await parse(ctx, deferred[i]);\n    }\n  }\n  return nodes;\n}\nasync function generateArrayNode(ctx, id, current) {\n  return {\n    t: 15,\n    i: id,\n    s: void 0,\n    l: current.length,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: await generateNodeList(ctx, current),\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateMapNode(ctx, id, current) {\n  assert(ctx.features & 32, 'Unsupported type \"Map\"');\n  const len = current.size;\n  const keyNodes = new Array(len);\n  const valueNodes = new Array(len);\n  const deferredKey = new Array(len);\n  const deferredValue = new Array(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const [key, value] of current.entries()) {\n    if (isIterable(key) || isIterable(value)) {\n      deferredKey[deferredSize] = key;\n      deferredValue[deferredSize] = value;\n      deferredSize++;\n    } else {\n      keyNodes[nodeSize] = await parse(ctx, key);\n      valueNodes[nodeSize] = await parse(ctx, value);\n      nodeSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodeSize + i] = await parse(ctx, deferredKey[i]);\n    valueNodes[nodeSize + i] = await parse(ctx, deferredValue[i]);\n  }\n  return {\n    t: 14,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: { k: keyNodes, v: valueNodes, s: len },\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateSetNode(ctx, id, current) {\n  assert(ctx.features & 512, 'Unsupported type \"Set\"');\n  const len = current.size;\n  const nodes = new Array(len);\n  const deferred = new Array(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const item of current.keys()) {\n    if (isIterable(item)) {\n      deferred[deferredSize++] = item;\n    } else {\n      nodes[nodeSize++] = await parse(ctx, item);\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    nodes[nodeSize + i] = await parse(ctx, deferred[i]);\n  }\n  return {\n    t: 13,\n    i: id,\n    s: void 0,\n    l: len,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: nodes,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateProperties(ctx, properties) {\n  const keys = Object.keys(properties);\n  const size = keys.length;\n  const keyNodes = new Array(size);\n  const valueNodes = new Array(size);\n  const deferredKeys = new Array(size);\n  const deferredValues = new Array(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item;\n  let escaped;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = await parse(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = await parse(ctx, deferredValues[i]);\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size\n  };\n}\nasync function generateIterableNode(ctx, id, current) {\n  assert(ctx.features & 1024, 'Unsupported type \"Iterable\"');\n  const options = getIterableOptions(current);\n  const array = Array.from(current);\n  return {\n    t: 21,\n    i: id,\n    s: void 0,\n    l: array.length,\n    c: void 0,\n    m: void 0,\n    // Parse options first before the items\n    d: options ? await generateProperties(ctx, options) : void 0,\n    a: await generateNodeList(ctx, array),\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generatePromiseNode(ctx, id, current) {\n  assert(ctx.features & 256, 'Unsupported type \"Promise\"');\n  return current.then(async (value) => ({\n    t: 18,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    // Parse options first before the items\n    d: void 0,\n    a: void 0,\n    f: await parse(ctx, value),\n    b: void 0\n  }));\n}\nasync function generateObjectNode(ctx, id, current, empty) {\n  if (Symbol.iterator in current) {\n    return generateIterableNode(ctx, id, current);\n  }\n  if (\"then\" in current && typeof current.then === \"function\") {\n    return generatePromiseNode(ctx, id, current);\n  }\n  return {\n    t: empty ? 17 : 16,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: await generateProperties(ctx, current),\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateAggregateErrorNode(ctx, id, current) {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options ? await generateProperties(ctx, options) : void 0;\n  return {\n    t: 20,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: serializeString(current.message),\n    d: optionsNode,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateErrorNode(ctx, id, current) {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options ? await generateProperties(ctx, options) : void 0;\n  return {\n    t: 19,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: getErrorConstructorName(current),\n    m: serializeString(current.message),\n    d: optionsNode,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateHeadersNode(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"Headers\"');\n  const items = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: 32,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: await generateProperties(ctx, items),\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateFormDataNode(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"FormData\"');\n  const items = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: 33,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: await generateProperties(ctx, items),\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function parse(ctx, current) {\n  switch (typeof current) {\n    case \"boolean\":\n      return current ? TRUE_NODE : FALSE_NODE;\n    case \"undefined\":\n      return UNDEFINED_NODE;\n    case \"string\":\n      return createStringNode(current);\n    case \"number\":\n      switch (current) {\n        case Infinity:\n          return INFINITY_NODE;\n        case -Infinity:\n          return NEG_INFINITY_NODE;\n        default:\n          if (current !== current) {\n            return NAN_NODE;\n          }\n          if (Object.is(current, -0)) {\n            return NEG_ZERO_NODE;\n          }\n          return createNumberNode(current);\n      }\n    case \"bigint\":\n      return createBigIntNode(ctx, current);\n    case \"object\": {\n      if (!current) {\n        return NULL_NODE;\n      }\n      const id = createIndexedValue(ctx, current);\n      if (ctx.markedRefs.has(id)) {\n        return createIndexedValueNode(id);\n      }\n      if (hasReferenceID(current)) {\n        return createReferenceNode(id, current);\n      }\n      if (Array.isArray(current)) {\n        return generateArrayNode(ctx, id, current);\n      }\n      switch (current.constructor) {\n        case Date:\n          return createDateNode(id, current);\n        case RegExp:\n          return createRegExpNode(id, current);\n        case Promise:\n          return generatePromiseNode(ctx, id, current);\n        case ArrayBuffer:\n          return createArrayBufferNode(id, current);\n        case Int8Array:\n        case Int16Array:\n        case Int32Array:\n        case Uint8Array:\n        case Uint16Array:\n        case Uint32Array:\n        case Uint8ClampedArray:\n        case Float32Array:\n        case Float64Array:\n          return createTypedArrayNode(ctx, id, current);\n        case BigInt64Array:\n        case BigUint64Array:\n          return createBigIntTypedArrayNode(ctx, id, current);\n        case DataView:\n          return createDataViewNode(ctx, id, current);\n        case Map:\n          return generateMapNode(\n            ctx,\n            id,\n            current\n          );\n        case Set:\n          return generateSetNode(\n            ctx,\n            id,\n            current\n          );\n        case Object:\n          return generateObjectNode(\n            ctx,\n            id,\n            current,\n            false\n          );\n        case void 0:\n          return generateObjectNode(\n            ctx,\n            id,\n            current,\n            true\n          );\n        case AggregateError:\n          if (ctx.features & 1) {\n            return generateAggregateErrorNode(ctx, id, current);\n          }\n          return generateErrorNode(ctx, id, current);\n        case Error:\n        case EvalError:\n        case RangeError:\n        case ReferenceError:\n        case SyntaxError:\n        case TypeError:\n        case URIError:\n          return generateErrorNode(ctx, id, current);\n        case URL:\n          return createURLNode(ctx, id, current);\n        case URLSearchParams:\n          return createURLSearchParamsNode(ctx, id, current);\n        case Blob:\n          return createBlobNode(ctx, id, current);\n        case File:\n          return createFileNode(ctx, id, current);\n        case Headers:\n          return generateHeadersNode(ctx, id, current);\n        case FormData:\n          return generateFormDataNode(ctx, id, current);\n        default:\n          break;\n      }\n      if (current instanceof AggregateError) {\n        if (ctx.features & 1) {\n          return generateAggregateErrorNode(ctx, id, current);\n        }\n        return generateErrorNode(ctx, id, current);\n      }\n      if (current instanceof Error) {\n        return generateErrorNode(ctx, id, current);\n      }\n      if (current instanceof Promise) {\n        return generatePromiseNode(ctx, id, current);\n      }\n      if (Symbol.iterator in current) {\n        return generateIterableNode(ctx, id, current);\n      }\n      if (\"then\" in current && typeof current.then === \"function\") {\n        return generatePromiseNode(ctx, id, current);\n      }\n      throw new Error(\"Unsupported type\");\n    }\n    case \"symbol\":\n      if (hasReferenceID(current)) {\n        const id = createIndexedValue(ctx, current);\n        if (ctx.markedRefs.has(id)) {\n          return createIndexedValueNode(id);\n        }\n        return createReferenceNode(id, current);\n      }\n      return createWKSymbolNode(ctx, current);\n    case \"function\": {\n      assert(hasReferenceID(current), \"Cannot serialize function without reference ID.\");\n      const id = createIndexedValue(ctx, current);\n      if (ctx.markedRefs.has(id)) {\n        return createIndexedValueNode(id);\n      }\n      return createReferenceNode(id, current);\n    }\n    default:\n      throw new Error(\"Unsupported type\");\n  }\n}\nasync function parseAsync(ctx, current) {\n  const result = await parse(ctx, current);\n  const isObject = result.t === 16 || result.t === 21;\n  return [result, getRootID(ctx, current), isObject];\n}\nfunction assignIndexedValue(ctx, index, value) {\n  if (ctx.markedRefs.has(index)) {\n    ctx.valueMap.set(index, value);\n  }\n  return value;\n}\nfunction deserializeArray(ctx, node) {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new Array(node.l)\n  );\n  let item;\n  for (let i = 0, len = node.l; i < len; i++) {\n    item = node.a[i];\n    if (item) {\n      result[i] = deserializeTree(ctx, item);\n    }\n  }\n  return result;\n}\nfunction deserializeProperties(ctx, node, result) {\n  if (node.s === 0) {\n    return {};\n  }\n  for (let i = 0; i < node.s; i++) {\n    result[deserializeString(node.k[i])] = deserializeTree(ctx, node.v[i]);\n  }\n  return result;\n}\nfunction deserializeNullConstructor(ctx, node) {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    /* @__PURE__ */ Object.create(null)\n  );\n  deserializeProperties(ctx, node.d, result);\n  return result;\n}\nfunction deserializeObject(ctx, node) {\n  const result = assignIndexedValue(ctx, node.i, {});\n  deserializeProperties(ctx, node.d, result);\n  return result;\n}\nfunction deserializeSet(ctx, node) {\n  const result = assignIndexedValue(ctx, node.i, /* @__PURE__ */ new Set());\n  for (let i = 0, len = node.l; i < len; i++) {\n    result.add(deserializeTree(ctx, node.a[i]));\n  }\n  return result;\n}\nfunction deserializeMap(ctx, node) {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    /* @__PURE__ */ new Map()\n  );\n  for (let i = 0, len = node.d.s; i < len; i++) {\n    result.set(\n      deserializeTree(ctx, node.d.k[i]),\n      deserializeTree(ctx, node.d.v[i])\n    );\n  }\n  return result;\n}\nfunction deserializeDictionary(ctx, node, result) {\n  if (node.d) {\n    const fields = deserializeProperties(ctx, node.d, {});\n    Object.assign(result, fields);\n  }\n  return result;\n}\nfunction deserializeAggregateError(ctx, node) {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new AggregateError([], deserializeString(node.m))\n  );\n  return deserializeDictionary(ctx, node, result);\n}\nfunction deserializeError(ctx, node) {\n  const ErrorConstructor = getErrorConstructor(node.c);\n  const result = assignIndexedValue(ctx, node.i, new ErrorConstructor(deserializeString(node.m)));\n  return deserializeDictionary(ctx, node, result);\n}\nfunction createDeferred() {\n  let resolver;\n  return {\n    resolve(v) {\n      resolver(v);\n    },\n    promise: new Promise((res) => {\n      resolver = res;\n    })\n  };\n}\nfunction deserializePromise(ctx, node) {\n  const deferred = createDeferred();\n  const result = assignIndexedValue(ctx, node.i, deferred.promise);\n  deferred.resolve(deserializeTree(ctx, node.f));\n  return result;\n}\nfunction deserializeArrayBuffer(ctx, node) {\n  const bytes = new Uint8Array(node.s);\n  const result = assignIndexedValue(ctx, node.i, bytes.buffer);\n  return result;\n}\nfunction deserializeTypedArray(ctx, node) {\n  const TypedArray = getTypedArrayConstructor(node.c);\n  const source = deserializeTree(ctx, node.f);\n  const result = assignIndexedValue(ctx, node.i, new TypedArray(\n    source,\n    node.b,\n    node.l\n  ));\n  return result;\n}\nfunction deserializeIterable(ctx, node) {\n  const values = [];\n  let item;\n  for (let i = 0, len = node.l; i < len; i++) {\n    item = node.a[i];\n    if (item) {\n      values[i] = deserializeTree(ctx, item);\n    }\n  }\n  const result = assignIndexedValue(ctx, node.i, {\n    [Symbol.iterator]: () => values.values()\n  });\n  return deserializeDictionary(ctx, node, result);\n}\nfunction deserializeDate(ctx, node) {\n  return assignIndexedValue(ctx, node.i, new Date(node.s));\n}\nfunction deserializeRegExp(ctx, node) {\n  return assignIndexedValue(ctx, node.i, new RegExp(node.c, node.m));\n}\nfunction deserializeURL(ctx, node) {\n  return assignIndexedValue(ctx, node.i, new URL(deserializeString(node.s)));\n}\nfunction deserializeURLSearchParams(ctx, node) {\n  return assignIndexedValue(ctx, node.i, new URLSearchParams(deserializeString(node.s)));\n}\nfunction deserializeReference(ctx, node) {\n  return assignIndexedValue(ctx, node.i, getReference(deserializeString(node.s)));\n}\nfunction deserializeDataView(ctx, node) {\n  const source = deserializeTree(ctx, node.f);\n  const result = assignIndexedValue(ctx, node.i, new DataView(\n    source,\n    node.b,\n    node.l\n  ));\n  return result;\n}\nfunction deserializeBlob(ctx, node) {\n  const source = deserializeTree(ctx, node.f);\n  const result = assignIndexedValue(ctx, node.i, new Blob(\n    [source],\n    { type: deserializeString(node.c) }\n  ));\n  return result;\n}\nfunction deserializeFile(ctx, node) {\n  const source = deserializeTree(ctx, node.f);\n  const result = assignIndexedValue(ctx, node.i, new File(\n    [source],\n    deserializeString(node.m),\n    { type: deserializeString(node.c), lastModified: node.b }\n  ));\n  return result;\n}\nfunction deserializeHeaders(ctx, node) {\n  const result = assignIndexedValue(ctx, node.i, new Headers());\n  for (let i = 0, len = node.d.s; i < len; i++) {\n    result.set(\n      deserializeString(node.d.k[i]),\n      deserializeTree(ctx, node.d.v[i])\n    );\n  }\n  return result;\n}\nfunction deserializeFormData(ctx, node) {\n  const result = assignIndexedValue(ctx, node.i, new FormData());\n  for (let i = 0, len = node.d.s; i < len; i++) {\n    result.set(\n      deserializeString(node.d.k[i]),\n      deserializeTree(ctx, node.d.v[i])\n    );\n  }\n  return result;\n}\nfunction deserializeTree(ctx, node) {\n  switch (node.t) {\n    case 0:\n    case 2:\n      return node.s;\n    case 1:\n      return deserializeString(node.s);\n    case 4:\n      return void 0;\n    case 3:\n      return null;\n    case 5:\n      return -0;\n    case 6:\n      return Infinity;\n    case 7:\n      return -Infinity;\n    case 8:\n      return NaN;\n    case 9:\n      return BigInt(node.s);\n    case 10:\n      return ctx.valueMap.get(node.i);\n    case 15:\n      return deserializeArray(ctx, node);\n    case 16:\n      return deserializeObject(ctx, node);\n    case 17:\n      return deserializeNullConstructor(ctx, node);\n    case 11:\n      return deserializeDate(ctx, node);\n    case 12:\n      return deserializeRegExp(ctx, node);\n    case 13:\n      return deserializeSet(ctx, node);\n    case 14:\n      return deserializeMap(ctx, node);\n    case 28:\n      return deserializeArrayBuffer(ctx, node);\n    case 23:\n    case 22:\n      return deserializeTypedArray(ctx, node);\n    case 29:\n      return deserializeDataView(ctx, node);\n    case 20:\n      return deserializeAggregateError(ctx, node);\n    case 19:\n      return deserializeError(ctx, node);\n    case 21:\n      return deserializeIterable(ctx, node);\n    case 18:\n      return deserializePromise(ctx, node);\n    case 24:\n      return SYMBOL_REF[node.s];\n    case 25:\n      return deserializeURL(ctx, node);\n    case 26:\n      return deserializeURLSearchParams(ctx, node);\n    case 27:\n      return deserializeReference(ctx, node);\n    case 30:\n      return deserializeBlob(ctx, node);\n    case 31:\n      return deserializeFile(ctx, node);\n    case 32:\n      return deserializeHeaders(ctx, node);\n    case 33:\n      return deserializeFormData(ctx, node);\n    default:\n      throw new Error(\"Unsupported type\");\n  }\n}\nfunction getAssignmentExpression(assignment) {\n  switch (assignment.t) {\n    case \"index\":\n      return assignment.s + \"=\" + assignment.v;\n    case \"set\":\n      return assignment.s + \".set(\" + assignment.k + \",\" + assignment.v + \")\";\n    case \"add\":\n      return assignment.s + \".add(\" + assignment.v + \")\";\n    case \"append\":\n      return assignment.s + \".append(\" + assignment.k + \",\" + assignment.v + \")\";\n    default:\n      return \"\";\n  }\n}\nfunction mergeAssignments(assignments) {\n  const newAssignments = [];\n  let current = assignments[0];\n  let prev = current;\n  let item;\n  for (let i = 1, len = assignments.length; i < len; i++) {\n    item = assignments[i];\n    if (item.t === prev.t) {\n      switch (item.t) {\n        case \"index\":\n          if (item.v === prev.v) {\n            current = {\n              t: \"index\",\n              s: item.s,\n              k: void 0,\n              v: getAssignmentExpression(current)\n            };\n          } else {\n            newAssignments.push(current);\n            current = item;\n          }\n          break;\n        case \"set\":\n          if (item.s === prev.s) {\n            current = {\n              t: \"set\",\n              s: getAssignmentExpression(current),\n              k: item.k,\n              v: item.v\n            };\n          } else {\n            newAssignments.push(current);\n            current = item;\n          }\n          break;\n        case \"add\":\n          if (item.s === prev.s) {\n            current = {\n              t: \"add\",\n              s: getAssignmentExpression(current),\n              k: void 0,\n              v: item.v\n            };\n          } else {\n            newAssignments.push(current);\n            current = item;\n          }\n          break;\n        case \"append\":\n          newAssignments.push(current);\n          current = item;\n          break;\n        default:\n          break;\n      }\n    } else {\n      newAssignments.push(current);\n      current = item;\n    }\n    prev = item;\n  }\n  newAssignments.push(current);\n  return newAssignments;\n}\nfunction resolveAssignments(assignments) {\n  if (assignments.length) {\n    let result = \"\";\n    const merged = mergeAssignments(assignments);\n    for (let i = 0, len = merged.length; i < len; i++) {\n      result += getAssignmentExpression(merged[i]) + \",\";\n    }\n    return result;\n  }\n  return void 0;\n}\nfunction resolvePatches(ctx) {\n  return resolveAssignments(ctx.assignments);\n}\nfunction createAssignment(ctx, source, value) {\n  ctx.assignments.push({\n    t: \"index\",\n    s: source,\n    k: void 0,\n    v: value\n  });\n}\nfunction createAddAssignment(ctx, ref, value) {\n  ctx.assignments.push({\n    t: \"add\",\n    s: getRefParam(ctx, ref),\n    k: void 0,\n    v: value\n  });\n}\nfunction createSetAssignment(ctx, ref, key, value) {\n  ctx.assignments.push({\n    t: \"set\",\n    s: getRefParam(ctx, ref),\n    k: key,\n    v: value\n  });\n}\nfunction createAppendAssignment(ctx, ref, key, value) {\n  ctx.assignments.push({\n    t: \"append\",\n    s: getRefParam(ctx, ref),\n    k: key,\n    v: value\n  });\n}\nfunction createArrayAssign(ctx, ref, index, value) {\n  createAssignment(ctx, getRefParam(ctx, ref) + \"[\" + index + \"]\", value);\n}\nfunction createObjectAssign(ctx, ref, key, value) {\n  markRef(ctx, ref);\n  createAssignment(ctx, getRefParam(ctx, ref) + \".\" + key, value);\n}\nfunction assignIndexedValue2(ctx, index, value) {\n  if (ctx.markedRefs.has(index)) {\n    return getRefParam(ctx, index) + \"=\" + value;\n  }\n  return value;\n}\nfunction isIndexedValueInStack(ctx, node) {\n  return node.t === 10 && ctx.stack.includes(node.i);\n}\nfunction serializeNodeList(ctx, node) {\n  const size = node.l;\n  let values = \"\";\n  let item;\n  let isHoley = false;\n  for (let i = 0; i < size; i++) {\n    if (i !== 0) {\n      values += \",\";\n    }\n    item = node.a[i];\n    if (item) {\n      if (isIndexedValueInStack(ctx, item)) {\n        markRef(ctx, node.i);\n        createArrayAssign(ctx, node.i, i, getRefParam(ctx, item.i));\n        isHoley = true;\n      } else {\n        values += serializeTree(ctx, item);\n        isHoley = false;\n      }\n    } else {\n      isHoley = true;\n    }\n  }\n  return \"[\" + values + (isHoley ? \",]\" : \"]\");\n}\nfunction serializeArray(ctx, node) {\n  ctx.stack.push(node.i);\n  const result = serializeNodeList(ctx, node);\n  ctx.stack.pop();\n  return assignIndexedValue2(ctx, node.i, result);\n}\nfunction serializeProperties(ctx, sourceID, node) {\n  if (node.s === 0) {\n    return \"{}\";\n  }\n  let result = \"\";\n  ctx.stack.push(sourceID);\n  let key;\n  let val;\n  let check;\n  let isIdentifier;\n  let refParam;\n  let hasPrev = false;\n  const keys = node.k;\n  const values = node.v;\n  for (let i = 0, len = node.s; i < len; i++) {\n    key = keys[i];\n    val = values[i];\n    check = Number(key);\n    isIdentifier = check >= 0 || isValidIdentifier(key);\n    if (isIndexedValueInStack(ctx, val)) {\n      refParam = getRefParam(ctx, val.i);\n      if (isIdentifier && Number.isNaN(check)) {\n        markRef(ctx, sourceID);\n        createObjectAssign(ctx, sourceID, key, refParam);\n      } else {\n        markRef(ctx, sourceID);\n        createArrayAssign(ctx, sourceID, isIdentifier ? key : '\"' + key + '\"', refParam);\n      }\n    } else {\n      result += (hasPrev ? \",\" : \"\") + (isIdentifier ? key : '\"' + key + '\"') + \":\" + serializeTree(ctx, val);\n      hasPrev = true;\n    }\n  }\n  ctx.stack.pop();\n  return \"{\" + result + \"}\";\n}\nfunction serializeWithObjectAssign(ctx, value, id, serialized) {\n  const fields = serializeProperties(ctx, id, value);\n  if (fields !== \"{}\") {\n    return \"Object.assign(\" + serialized + \",\" + fields + \")\";\n  }\n  return serialized;\n}\nfunction serializeAssignments(ctx, sourceID, node) {\n  ctx.stack.push(sourceID);\n  const mainAssignments = [];\n  let parentStack;\n  let refParam;\n  let key;\n  let check;\n  let parentAssignment;\n  let isIdentifier;\n  const keys = node.k;\n  const values = node.v;\n  for (let i = 0, len = node.s; i < len; i++) {\n    parentStack = ctx.stack;\n    ctx.stack = [];\n    refParam = serializeTree(ctx, values[i]);\n    ctx.stack = parentStack;\n    key = keys[i];\n    check = Number(key);\n    parentAssignment = ctx.assignments;\n    ctx.assignments = mainAssignments;\n    isIdentifier = check >= 0 || isValidIdentifier(key);\n    if (isIdentifier && Number.isNaN(check)) {\n      createObjectAssign(ctx, sourceID, key, refParam);\n    } else {\n      createArrayAssign(ctx, sourceID, isIdentifier ? key : '\"' + key + '\"', refParam);\n    }\n    ctx.assignments = parentAssignment;\n  }\n  ctx.stack.pop();\n  return resolveAssignments(mainAssignments);\n}\nfunction serializeDictionary(ctx, i, d, init) {\n  if (d) {\n    if (ctx.features & 128) {\n      init = serializeWithObjectAssign(ctx, d, i, init);\n    } else {\n      markRef(ctx, i);\n      const assignments = serializeAssignments(ctx, i, d);\n      if (assignments) {\n        return \"(\" + assignIndexedValue2(ctx, i, init) + \",\" + assignments + getRefParam(ctx, i) + \")\";\n      }\n    }\n  }\n  return assignIndexedValue2(ctx, i, init);\n}\nfunction serializeNullConstructor(ctx, node) {\n  return serializeDictionary(ctx, node.i, node.d, \"Object.create(null)\");\n}\nfunction serializeObject(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, serializeProperties(ctx, node.i, node.d));\n}\nfunction serializeSet(ctx, node) {\n  let serialized = \"new Set\";\n  const size = node.l;\n  if (size) {\n    let result = \"\";\n    ctx.stack.push(node.i);\n    let item;\n    let hasPrev = false;\n    for (let i = 0; i < size; i++) {\n      item = node.a[i];\n      if (isIndexedValueInStack(ctx, item)) {\n        markRef(ctx, node.i);\n        createAddAssignment(ctx, node.i, getRefParam(ctx, item.i));\n      } else {\n        result += (hasPrev ? \",\" : \"\") + serializeTree(ctx, item);\n        hasPrev = true;\n      }\n    }\n    ctx.stack.pop();\n    if (result) {\n      serialized += \"([\" + result + \"])\";\n    }\n  }\n  return assignIndexedValue2(ctx, node.i, serialized);\n}\nfunction serializeMap(ctx, node) {\n  let serialized = \"new Map\";\n  if (node.d.s) {\n    let result = \"\";\n    ctx.stack.push(node.i);\n    let key;\n    let val;\n    let keyRef;\n    let valueRef;\n    let parent;\n    let hasPrev = false;\n    for (let i = 0; i < node.d.s; i++) {\n      key = node.d.k[i];\n      val = node.d.v[i];\n      if (isIndexedValueInStack(ctx, key)) {\n        keyRef = getRefParam(ctx, key.i);\n        markRef(ctx, node.i);\n        if (isIndexedValueInStack(ctx, val)) {\n          valueRef = getRefParam(ctx, val.i);\n          createSetAssignment(ctx, node.i, keyRef, valueRef);\n        } else {\n          parent = ctx.stack;\n          ctx.stack = [];\n          createSetAssignment(ctx, node.i, keyRef, serializeTree(ctx, val));\n          ctx.stack = parent;\n        }\n      } else if (isIndexedValueInStack(ctx, val)) {\n        valueRef = getRefParam(ctx, val.i);\n        markRef(ctx, node.i);\n        parent = ctx.stack;\n        ctx.stack = [];\n        createSetAssignment(ctx, node.i, serializeTree(ctx, key), valueRef);\n        ctx.stack = parent;\n      } else {\n        result += (hasPrev ? \",[\" : \"[\") + serializeTree(ctx, key) + \",\" + serializeTree(ctx, val) + \"]\";\n        hasPrev = true;\n      }\n    }\n    ctx.stack.pop();\n    if (result) {\n      serialized += \"([\" + result + \"])\";\n    }\n  }\n  return assignIndexedValue2(ctx, node.i, serialized);\n}\nfunction serializeAggregateError(ctx, node) {\n  ctx.stack.push(node.i);\n  const serialized = 'new AggregateError([],\"' + node.m + '\")';\n  ctx.stack.pop();\n  return serializeDictionary(ctx, node.i, node.d, serialized);\n}\nfunction serializeError(ctx, node) {\n  const serialized = \"new \" + node.c + '(\"' + node.m + '\")';\n  return serializeDictionary(ctx, node.i, node.d, serialized);\n}\nfunction serializePromise(ctx, node) {\n  let serialized;\n  if (isIndexedValueInStack(ctx, node.f)) {\n    const ref = getRefParam(ctx, node.f.i);\n    if (ctx.features & 4) {\n      serialized = \"Promise.resolve().then(()=>\" + ref + \")\";\n    } else {\n      serialized = \"Promise.resolve().then(function(){return \" + ref + \"})\";\n    }\n  } else {\n    ctx.stack.push(node.i);\n    const result = serializeTree(ctx, node.f);\n    ctx.stack.pop();\n    serialized = \"Promise.resolve(\" + result + \")\";\n  }\n  return assignIndexedValue2(ctx, node.i, serialized);\n}\nfunction serializeArrayBuffer2(ctx, node) {\n  let result = \"new Uint8Array(\";\n  if (node.s.length) {\n    result += \"[\";\n    for (let i = 0, len = node.s.length; i < len; i++) {\n      result += (i > 0 ? \",\" : \"\") + node.s[i];\n    }\n    result += \"]\";\n  }\n  return assignIndexedValue2(ctx, node.i, result + \").buffer\");\n}\nfunction serializeTypedArray(ctx, node) {\n  const args = serializeTree(ctx, node.f) + \",\" + node.b + \",\" + node.l;\n  return assignIndexedValue2(ctx, node.i, \"new \" + node.c + \"(\" + args + \")\");\n}\nfunction serializeIterable(ctx, node) {\n  const parent = ctx.stack;\n  ctx.stack = [];\n  const values = serializeNodeList(ctx, node);\n  ctx.stack = parent;\n  let serialized = values;\n  if (ctx.features & 2) {\n    serialized += \".values()\";\n  } else {\n    serialized += \"[Symbol.iterator]()\";\n  }\n  if (ctx.features & 4) {\n    serialized = \"{[Symbol.iterator]:()=>\" + serialized + \"}\";\n  } else if (ctx.features & 64) {\n    serialized = \"{[Symbol.iterator](){return \" + serialized + \"}}\";\n  } else {\n    serialized = \"{[Symbol.iterator]:function(){return \" + serialized + \"}}\";\n  }\n  return serializeDictionary(ctx, node.i, node.d, serialized);\n}\nfunction serializeDate(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, 'new Date(\"' + node.s + '\")');\n}\nfunction serializeRegExp(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, \"/\" + node.c + \"/\" + node.m);\n}\nfunction serializeURL(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, 'new URL(\"' + node.s + '\")');\n}\nfunction serializeURLSearchParams(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, node.s ? 'new URLSearchParams(\"' + node.s + '\")' : \"new URLSearchParams\");\n}\nfunction serializeReference(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, GLOBAL_KEY + '.get(\"' + node.s + '\")');\n}\nfunction serializeDataView(ctx, node) {\n  const args = serializeTree(ctx, node.f) + \",\" + node.b + \",\" + node.l;\n  return assignIndexedValue2(ctx, node.i, \"new DataView(\" + args + \")\");\n}\nfunction serializeBlob(ctx, node) {\n  const args = \"[\" + serializeTree(ctx, node.f) + '],{type:\"' + node.c + '\"}';\n  return assignIndexedValue2(ctx, node.i, \"new Blob(\" + args + \")\");\n}\nfunction serializeFile(ctx, node) {\n  const options = '{type:\"' + node.c + '\",lastModified:' + node.b + \"}\";\n  const args = \"[\" + serializeTree(ctx, node.f) + '],\"' + node.m + '\",' + options;\n  return assignIndexedValue2(ctx, node.i, \"new File(\" + args + \")\");\n}\nfunction serializeHeaders(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, \"new Headers(\" + serializeProperties(ctx, node.i, node.d) + \")\");\n}\nfunction serializeFormDataEntries(ctx, node) {\n  ctx.stack.push(node.i);\n  const mainAssignments = [];\n  let parentStack;\n  let value;\n  let key;\n  let parentAssignment;\n  for (let i = 0; i < node.d.s; i++) {\n    parentStack = ctx.stack;\n    ctx.stack = [];\n    value = serializeTree(ctx, node.d.v[i]);\n    key = node.d.k[i];\n    ctx.stack = parentStack;\n    parentAssignment = ctx.assignments;\n    ctx.assignments = mainAssignments;\n    createAppendAssignment(ctx, node.i, '\"' + key + '\"', value);\n    ctx.assignments = parentAssignment;\n  }\n  ctx.stack.pop();\n  return resolveAssignments(mainAssignments);\n}\nfunction serializeFormData(ctx, node) {\n  if (node.d.s) {\n    markRef(ctx, node.i);\n  }\n  const result = assignIndexedValue2(ctx, node.i, \"new FormData()\");\n  if (node.d.s) {\n    return \"(\" + result + \",\" + serializeFormDataEntries(ctx, node) + getRefParam(ctx, node.i) + \")\";\n  }\n  return result;\n}\nfunction serializeTree(ctx, node) {\n  switch (node.t) {\n    case 0:\n      return \"\" + node.s;\n    case 1:\n      return '\"' + node.s + '\"';\n    case 2:\n      return node.s ? \"!0\" : \"!1\";\n    case 4:\n      return \"void 0\";\n    case 3:\n      return \"null\";\n    case 5:\n      return \"-0\";\n    case 6:\n      return \"1/0\";\n    case 7:\n      return \"-1/0\";\n    case 8:\n      return \"NaN\";\n    case 9:\n      return node.s + \"n\";\n    case 10:\n      return getRefParam(ctx, node.i);\n    case 15:\n      return serializeArray(ctx, node);\n    case 16:\n      return serializeObject(ctx, node);\n    case 17:\n      return serializeNullConstructor(ctx, node);\n    case 11:\n      return serializeDate(ctx, node);\n    case 12:\n      return serializeRegExp(ctx, node);\n    case 13:\n      return serializeSet(ctx, node);\n    case 14:\n      return serializeMap(ctx, node);\n    case 28:\n      return serializeArrayBuffer2(ctx, node);\n    case 23:\n    case 22:\n      return serializeTypedArray(ctx, node);\n    case 29:\n      return serializeDataView(ctx, node);\n    case 20:\n      return serializeAggregateError(ctx, node);\n    case 19:\n      return serializeError(ctx, node);\n    case 21:\n      return serializeIterable(ctx, node);\n    case 18:\n      return serializePromise(ctx, node);\n    case 24:\n      return SYMBOL_STRING[node.s];\n    case 25:\n      return serializeURL(ctx, node);\n    case 26:\n      return serializeURLSearchParams(ctx, node);\n    case 27:\n      return serializeReference(ctx, node);\n    case 30:\n      return serializeBlob(ctx, node);\n    case 31:\n      return serializeFile(ctx, node);\n    case 32:\n      return serializeHeaders(ctx, node);\n    case 33:\n      return serializeFormData(ctx, node);\n    default:\n      throw new Error(\"Unsupported type\");\n  }\n}\nfunction generateNodeList2(ctx, current) {\n  const size = current.length;\n  const nodes = new Array(size);\n  const deferred = new Array(size);\n  let item;\n  for (let i = 0; i < size; i++) {\n    if (i in current) {\n      item = current[i];\n      if (isIterable(item)) {\n        deferred[i] = item;\n      } else {\n        nodes[i] = parse2(ctx, item);\n      }\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    if (i in deferred) {\n      nodes[i] = parse2(ctx, deferred[i]);\n    }\n  }\n  return nodes;\n}\nfunction generateArrayNode2(ctx, id, current) {\n  return {\n    t: 15,\n    i: id,\n    s: void 0,\n    l: current.length,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: generateNodeList2(ctx, current),\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateMapNode2(ctx, id, current) {\n  assert(ctx.features & 32, 'Unsupported type \"Map\"');\n  const len = current.size;\n  const keyNodes = new Array(len);\n  const valueNodes = new Array(len);\n  const deferredKey = new Array(len);\n  const deferredValue = new Array(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const [key, value] of current.entries()) {\n    if (isIterable(key) || isIterable(value)) {\n      deferredKey[deferredSize] = key;\n      deferredValue[deferredSize] = value;\n      deferredSize++;\n    } else {\n      keyNodes[nodeSize] = parse2(ctx, key);\n      valueNodes[nodeSize] = parse2(ctx, value);\n      nodeSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodeSize + i] = parse2(ctx, deferredKey[i]);\n    valueNodes[nodeSize + i] = parse2(ctx, deferredValue[i]);\n  }\n  return {\n    t: 14,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: { k: keyNodes, v: valueNodes, s: len },\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateSetNode2(ctx, id, current) {\n  assert(ctx.features & 512, 'Unsupported type \"Set\"');\n  const len = current.size;\n  const nodes = new Array(len);\n  const deferred = new Array(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const item of current.keys()) {\n    if (isIterable(item)) {\n      deferred[deferredSize++] = item;\n    } else {\n      nodes[nodeSize++] = parse2(ctx, item);\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    nodes[nodeSize + i] = parse2(ctx, deferred[i]);\n  }\n  return {\n    t: 13,\n    i: id,\n    s: void 0,\n    l: len,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: nodes,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateProperties2(ctx, properties) {\n  const keys = Object.keys(properties);\n  const size = keys.length;\n  const keyNodes = new Array(size);\n  const valueNodes = new Array(size);\n  const deferredKeys = new Array(size);\n  const deferredValues = new Array(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item;\n  let escaped;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = parse2(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = parse2(ctx, deferredValues[i]);\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size\n  };\n}\nfunction generateIterableNode2(ctx, id, current) {\n  assert(ctx.features & 1024, 'Unsupported type \"Iterable\"');\n  const options = getIterableOptions(current);\n  const array = Array.from(current);\n  return {\n    t: 21,\n    i: id,\n    s: void 0,\n    l: array.length,\n    c: void 0,\n    m: void 0,\n    // Parse options first before the items\n    d: options ? generateProperties2(ctx, options) : void 0,\n    a: generateNodeList2(ctx, array),\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateObjectNode2(ctx, id, current, empty) {\n  if (Symbol.iterator in current) {\n    return generateIterableNode2(ctx, id, current);\n  }\n  return {\n    t: empty ? 17 : 16,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: generateProperties2(ctx, current),\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateAggregateErrorNode2(ctx, id, current) {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options ? generateProperties2(ctx, options) : void 0;\n  return {\n    t: 20,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: serializeString(current.message),\n    d: optionsNode,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateErrorNode2(ctx, id, current) {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options ? generateProperties2(ctx, options) : void 0;\n  return {\n    t: 19,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: getErrorConstructorName(current),\n    m: serializeString(current.message),\n    d: optionsNode,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateHeadersNode2(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"Headers\"');\n  const items = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: 32,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: generateProperties2(ctx, items),\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateFormDataNode2(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"FormData\"');\n  const items = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: 33,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: generateProperties2(ctx, items),\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction parse2(ctx, current) {\n  switch (typeof current) {\n    case \"boolean\":\n      return current ? TRUE_NODE : FALSE_NODE;\n    case \"undefined\":\n      return UNDEFINED_NODE;\n    case \"string\":\n      return createStringNode(current);\n    case \"number\":\n      switch (current) {\n        case Infinity:\n          return INFINITY_NODE;\n        case -Infinity:\n          return NEG_INFINITY_NODE;\n        default:\n          if (current !== current) {\n            return NAN_NODE;\n          }\n          if (Object.is(current, -0)) {\n            return NEG_ZERO_NODE;\n          }\n          return createNumberNode(current);\n      }\n    case \"bigint\":\n      return createBigIntNode(ctx, current);\n    case \"object\": {\n      if (!current) {\n        return NULL_NODE;\n      }\n      const id = createIndexedValue(ctx, current);\n      if (ctx.markedRefs.has(id)) {\n        return createIndexedValueNode(id);\n      }\n      if (hasReferenceID(current)) {\n        return createReferenceNode(id, current);\n      }\n      if (Array.isArray(current)) {\n        return generateArrayNode2(ctx, id, current);\n      }\n      switch (current.constructor) {\n        case Date:\n          return createDateNode(id, current);\n        case RegExp:\n          return createRegExpNode(id, current);\n        case ArrayBuffer:\n          return createArrayBufferNode(id, current);\n        case Int8Array:\n        case Int16Array:\n        case Int32Array:\n        case Uint8Array:\n        case Uint16Array:\n        case Uint32Array:\n        case Uint8ClampedArray:\n        case Float32Array:\n        case Float64Array:\n          return createTypedArrayNode(ctx, id, current);\n        case BigInt64Array:\n        case BigUint64Array:\n          return createBigIntTypedArrayNode(ctx, id, current);\n        case DataView:\n          return createDataViewNode(ctx, id, current);\n        case Map:\n          return generateMapNode2(ctx, id, current);\n        case Set:\n          return generateSetNode2(ctx, id, current);\n        case Object:\n          return generateObjectNode2(\n            ctx,\n            id,\n            current,\n            false\n          );\n        case void 0:\n          return generateObjectNode2(\n            ctx,\n            id,\n            current,\n            true\n          );\n        case AggregateError:\n          if (ctx.features & 1) {\n            return generateAggregateErrorNode2(ctx, id, current);\n          }\n          return generateErrorNode2(ctx, id, current);\n        case Error:\n        case EvalError:\n        case RangeError:\n        case ReferenceError:\n        case SyntaxError:\n        case TypeError:\n        case URIError:\n          return generateErrorNode2(ctx, id, current);\n        case URL:\n          return createURLNode(ctx, id, current);\n        case URLSearchParams:\n          return createURLSearchParamsNode(ctx, id, current);\n        case Headers:\n          return generateHeadersNode2(ctx, id, current);\n        case FormData:\n          return generateFormDataNode2(ctx, id, current);\n        default:\n          break;\n      }\n      if (current instanceof AggregateError) {\n        if (ctx.features & 1) {\n          return generateAggregateErrorNode2(ctx, id, current);\n        }\n        return generateErrorNode2(ctx, id, current);\n      }\n      if (current instanceof Error) {\n        return generateErrorNode2(ctx, id, current);\n      }\n      if (Symbol.iterator in current) {\n        return generateIterableNode2(ctx, id, current);\n      }\n      throw new Error(\"Unsupported type\");\n    }\n    case \"symbol\":\n      if (hasReferenceID(current)) {\n        const id = createIndexedValue(ctx, current);\n        if (ctx.markedRefs.has(id)) {\n          return createIndexedValueNode(id);\n        }\n        return createReferenceNode(id, current);\n      }\n      return createWKSymbolNode(ctx, current);\n    case \"function\": {\n      assert(hasReferenceID(current), \"Cannot serialize function without reference ID.\");\n      const id = createIndexedValue(ctx, current);\n      if (ctx.markedRefs.has(id)) {\n        return createIndexedValueNode(id);\n      }\n      return createReferenceNode(id, current);\n    }\n    default:\n      throw new Error(\"Unsupported type\");\n  }\n}\nfunction parseSync(ctx, current) {\n  const result = parse2(ctx, current);\n  const isObject = result.t === 16 || result.t === 21;\n  return [result, getRootID(ctx, current), isObject];\n}\nfunction finalize(ctx, rootID, isObject, result) {\n  if (ctx.vars.length) {\n    const patches = resolvePatches(ctx);\n    let body = result;\n    if (patches) {\n      const index = getRefParam(ctx, rootID);\n      body = result + \",\" + patches + index;\n      if (!result.startsWith(index + \"=\")) {\n        body = index + \"=\" + body;\n      }\n    }\n    let params = ctx.vars.length > 1 ? ctx.vars.join(\",\") : ctx.vars[0];\n    if (ctx.features & 4) {\n      params = ctx.vars.length > 1 || ctx.vars.length === 0 ? \"(\" + params + \")\" : params;\n      return \"(\" + params + \"=>(\" + body + \"))()\";\n    }\n    return \"(function(\" + params + \"){return \" + body + \"})()\";\n  }\n  if (isObject) {\n    return \"(\" + result + \")\";\n  }\n  return result;\n}\nfunction serialize(source, options) {\n  const ctx = createParserContext(options);\n  const [tree, rootID, isObject] = parseSync(ctx, source);\n  const serial = createSerializationContext(ctx);\n  const result = serializeTree(serial, tree);\n  return finalize(serial, rootID, isObject, result);\n}\nasync function serializeAsync(source, options) {\n  const ctx = createParserContext(options);\n  const [tree, rootID, isObject] = await parseAsync(ctx, source);\n  const serial = createSerializationContext(ctx);\n  const result = serializeTree(serial, tree);\n  return finalize(serial, rootID, isObject, result);\n}\nfunction deserialize(source) {\n  return (0, eval)(source);\n}\nfunction toJSON(source, options) {\n  const ctx = createParserContext(options);\n  const [tree, root, isObject] = parseSync(ctx, source);\n  return {\n    t: tree,\n    r: root,\n    i: isObject,\n    f: ctx.features,\n    m: Array.from(ctx.markedRefs)\n  };\n}\nasync function toJSONAsync(source, options) {\n  const ctx = createParserContext(options);\n  const [tree, root, isObject] = await parseAsync(ctx, source);\n  return {\n    t: tree,\n    r: root,\n    i: isObject,\n    f: ctx.features,\n    m: Array.from(ctx.markedRefs)\n  };\n}\nfunction compileJSON(source) {\n  const serial = createSerializationContext({\n    features: source.f,\n    markedRefs: source.m\n  });\n  const result = serializeTree(serial, source.t);\n  return finalize(serial, source.r, source.i, result);\n}\nfunction fromJSON(source) {\n  const serial = createSerializationContext({\n    features: source.f,\n    markedRefs: source.m\n  });\n  return deserializeTree(serial, source.t);\n}\nvar src_default = serialize;\nexport {\n  Feature,\n  compileJSON,\n  createReference,\n  src_default as default,\n  deserialize,\n  fromJSON,\n  serialize,\n  serializeAsync,\n  toJSON,\n  toJSONAsync\n};\n//# sourceMappingURL=seroval.js.map\n","start":1681089268405,"end":1681089268659},{"name":"vite:import-analysis","result":"// ../../node_modules/.pnpm/seroval@0.7.0/node_modules/seroval/dist/esm/development/index.mjs\nvar Feature = ((Feature2) => {\n  Feature2[Feature2[\"AggregateError\"] = 1] = \"AggregateError\";\n  Feature2[Feature2[\"ArrayPrototypeValues\"] = 2] = \"ArrayPrototypeValues\";\n  Feature2[Feature2[\"ArrowFunction\"] = 4] = \"ArrowFunction\";\n  Feature2[Feature2[\"BigInt\"] = 8] = \"BigInt\";\n  Feature2[Feature2[\"ErrorPrototypeStack\"] = 16] = \"ErrorPrototypeStack\";\n  Feature2[Feature2[\"Map\"] = 32] = \"Map\";\n  Feature2[Feature2[\"MethodShorthand\"] = 64] = \"MethodShorthand\";\n  Feature2[Feature2[\"ObjectAssign\"] = 128] = \"ObjectAssign\";\n  Feature2[Feature2[\"Promise\"] = 256] = \"Promise\";\n  Feature2[Feature2[\"Set\"] = 512] = \"Set\";\n  Feature2[Feature2[\"Symbol\"] = 1024] = \"Symbol\";\n  Feature2[Feature2[\"TypedArray\"] = 2048] = \"TypedArray\";\n  Feature2[Feature2[\"BigIntTypedArray\"] = 4096] = \"BigIntTypedArray\";\n  Feature2[Feature2[\"WebAPI\"] = 8192] = \"WebAPI\";\n  return Feature2;\n})(Feature || {});\nvar ALL_ENABLED = 16383;\nvar REF_START_CHARS = \"hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_\";\nvar REF_START_CHARS_LEN = REF_START_CHARS.length;\nvar REF_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_\";\nvar REF_CHARS_LEN = REF_CHARS.length;\nfunction getIdentifier(index) {\n  let mod = index % REF_START_CHARS_LEN;\n  let ref = REF_START_CHARS[mod];\n  index = (index - mod) / REF_START_CHARS_LEN;\n  while (index > 0) {\n    mod = index % REF_CHARS_LEN;\n    ref += REF_CHARS[mod];\n    index = (index - mod) / REF_CHARS_LEN;\n  }\n  return ref;\n}\nvar DEFAULT_OPTIONS = {\n  disabledFeatures: 0\n};\nfunction createParserContext(options = {}) {\n  const result = Object.assign({}, DEFAULT_OPTIONS, options || {});\n  return {\n    markedRefs: /* @__PURE__ */ new Set(),\n    refs: /* @__PURE__ */ new Map(),\n    features: ALL_ENABLED ^ result.disabledFeatures\n  };\n}\nfunction createSerializationContext(options) {\n  return {\n    stack: [],\n    vars: [],\n    assignments: [],\n    validRefs: [],\n    refSize: 0,\n    features: options.features,\n    markedRefs: new Set(options.markedRefs),\n    valueMap: /* @__PURE__ */ new Map()\n  };\n}\nfunction markRef(ctx, current) {\n  ctx.markedRefs.add(current);\n}\nfunction getRefParam(ctx, index) {\n  let actualIndex = ctx.validRefs[index];\n  if (actualIndex == null) {\n    actualIndex = ctx.refSize++;\n    ctx.validRefs[index] = actualIndex;\n  }\n  let identifier = ctx.vars[actualIndex];\n  if (identifier == null) {\n    identifier = getIdentifier(actualIndex);\n    ctx.vars[actualIndex] = identifier;\n  }\n  return identifier;\n}\nfunction getRootID(ctx, current) {\n  const ref = ctx.refs.get(current);\n  if (ref == null) {\n    return ctx.refs.size;\n  }\n  return ref;\n}\nfunction createIndexedValue(ctx, current) {\n  const ref = ctx.refs.get(current);\n  if (ref == null) {\n    const id = ctx.refs.size;\n    ctx.refs.set(current, id);\n    return id;\n  }\n  markRef(ctx, ref);\n  return ref;\n}\nfunction assert(cond, error) {\n  if (!cond) {\n    throw new Error(error);\n  }\n}\nfunction serializeChar(str) {\n  switch (str) {\n    case '\"':\n      return '\\\\\"';\n    case \"\\\\\":\n      return \"\\\\\\\\\";\n    case \"\\n\":\n      return \"\\\\n\";\n    case \"\\r\":\n      return \"\\\\r\";\n    case \"\\b\":\n      return \"\\\\b\";\n    case \"\t\":\n      return \"\\\\t\";\n    case \"\\f\":\n      return \"\\\\f\";\n    case \"<\":\n      return \"\\\\x3C\";\n    case \"\\u2028\":\n      return \"\\\\u2028\";\n    case \"\\u2029\":\n      return \"\\\\u2029\";\n    default:\n      return void 0;\n  }\n}\nfunction serializeString(str) {\n  let result = \"\";\n  let lastPos = 0;\n  let replacement;\n  for (let i = 0, len = str.length; i < len; i++) {\n    replacement = serializeChar(str[i]);\n    if (replacement) {\n      result += str.slice(lastPos, i) + replacement;\n      lastPos = i + 1;\n    }\n  }\n  if (lastPos === 0) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n  return result;\n}\nfunction deserializeString(str) {\n  return str.replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, \"\\\\\").replace(/\\\\n/g, \"\\n\").replace(/\\\\r/g, \"\\r\").replace(/\\\\b/g, \"\\b\").replace(/\\\\t/g, \"\t\").replace(/\\\\f/g, \"\\f\").replace(/\\\\x3C/g, \"<\").replace(/\\\\u2028/g, \"\\u2028\").replace(/\\\\u2029/g, \"\\u2029\");\n}\nvar REFERENCE = /* @__PURE__ */ new Map();\nvar INV_REFERENCE = /* @__PURE__ */ new Map();\nfunction createReference(id, value) {\n  REFERENCE.set(value, id);\n  INV_REFERENCE.set(id, value);\n  return value;\n}\nfunction hasReferenceID(value) {\n  return REFERENCE.has(value);\n}\nfunction hasReference(id) {\n  return INV_REFERENCE.has(id);\n}\nfunction getReferenceID(value) {\n  assert(hasReferenceID(value), \"Missing reference id\");\n  return REFERENCE.get(value);\n}\nfunction getReference(id) {\n  assert(hasReference(id), \"Missing reference for id:\" + id);\n  return INV_REFERENCE.get(id);\n}\nvar GLOBAL_KEY = \"__SEROVAL__\";\nif (typeof globalThis !== void 0) {\n  Object.defineProperty(globalThis, GLOBAL_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n} else if (typeof window !== void 0) {\n  Object.defineProperty(window, GLOBAL_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n} else if (typeof self !== void 0) {\n  Object.defineProperty(self, GLOBAL_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n} else if (typeof global !== void 0) {\n  Object.defineProperty(global, GLOBAL_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n}\nvar SYMBOL_STRING = {\n  [\n    0\n    /* AsyncIterator */\n  ]: \"Symbol.asyncIterator\",\n  [\n    1\n    /* HasInstance */\n  ]: \"Symbol.hasInstance\",\n  [\n    2\n    /* IsConcatSpreadable */\n  ]: \"Symbol.isConcatSpreadable\",\n  [\n    3\n    /* Iterator */\n  ]: \"Symbol.iterator\",\n  [\n    4\n    /* Match */\n  ]: \"Symbol.match\",\n  [\n    5\n    /* MatchAll */\n  ]: \"Symbol.matchAll\",\n  [\n    6\n    /* Replace */\n  ]: \"Symbol.replace\",\n  [\n    7\n    /* Search */\n  ]: \"Symbol.search\",\n  [\n    8\n    /* Species */\n  ]: \"Symbol.species\",\n  [\n    9\n    /* Split */\n  ]: \"Symbol.split\",\n  [\n    10\n    /* ToPrimitive */\n  ]: \"Symbol.toPrimitive\",\n  [\n    11\n    /* ToStringTag */\n  ]: \"Symbol.toStringTag\",\n  [\n    12\n    /* Unscopables */\n  ]: \"Symbol.unscopables\"\n};\nvar INV_SYMBOL_REF = {\n  [Symbol.asyncIterator]: 0,\n  [Symbol.hasInstance]: 1,\n  [Symbol.isConcatSpreadable]: 2,\n  [Symbol.iterator]: 3,\n  [Symbol.match]: 4,\n  [Symbol.matchAll]: 5,\n  [Symbol.replace]: 6,\n  [Symbol.search]: 7,\n  [Symbol.species]: 8,\n  [Symbol.split]: 9,\n  [Symbol.toPrimitive]: 10,\n  [Symbol.toStringTag]: 11,\n  [Symbol.unscopables]: 12\n  /* Unscopables */\n};\nvar SYMBOL_REF = {\n  [\n    0\n    /* AsyncIterator */\n  ]: Symbol.asyncIterator,\n  [\n    1\n    /* HasInstance */\n  ]: Symbol.hasInstance,\n  [\n    2\n    /* IsConcatSpreadable */\n  ]: Symbol.isConcatSpreadable,\n  [\n    3\n    /* Iterator */\n  ]: Symbol.iterator,\n  [\n    4\n    /* Match */\n  ]: Symbol.match,\n  [\n    5\n    /* MatchAll */\n  ]: Symbol.matchAll,\n  [\n    6\n    /* Replace */\n  ]: Symbol.replace,\n  [\n    7\n    /* Search */\n  ]: Symbol.search,\n  [\n    8\n    /* Species */\n  ]: Symbol.species,\n  [\n    9\n    /* Split */\n  ]: Symbol.split,\n  [\n    10\n    /* ToPrimitive */\n  ]: Symbol.toPrimitive,\n  [\n    11\n    /* ToStringTag */\n  ]: Symbol.toStringTag,\n  [\n    12\n    /* Unscopables */\n  ]: Symbol.unscopables\n};\nvar TRUE_NODE = {\n  t: 2,\n  i: void 0,\n  s: true,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar FALSE_NODE = {\n  t: 2,\n  i: void 0,\n  s: false,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar UNDEFINED_NODE = {\n  t: 4,\n  i: void 0,\n  s: void 0,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar NULL_NODE = {\n  t: 3,\n  i: void 0,\n  s: void 0,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar NEG_ZERO_NODE = {\n  t: 5,\n  i: void 0,\n  s: void 0,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar INFINITY_NODE = {\n  t: 6,\n  i: void 0,\n  s: void 0,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar NEG_INFINITY_NODE = {\n  t: 7,\n  i: void 0,\n  s: void 0,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nvar NAN_NODE = {\n  t: 8,\n  i: void 0,\n  s: void 0,\n  l: void 0,\n  c: void 0,\n  m: void 0,\n  d: void 0,\n  a: void 0,\n  f: void 0,\n  b: void 0\n};\nfunction createNumberNode(value) {\n  return {\n    t: 0,\n    i: void 0,\n    s: value,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createStringNode(value) {\n  return {\n    t: 1,\n    i: void 0,\n    s: serializeString(value),\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createBigIntNode(ctx, current) {\n  assert(ctx.features & 8, 'Unsupported type \"BigInt\"');\n  return {\n    t: 9,\n    i: void 0,\n    s: \"\" + current,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createIndexedValueNode(id) {\n  return {\n    t: 10,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createDateNode(id, current) {\n  return {\n    t: 11,\n    i: id,\n    s: current.toISOString(),\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    f: void 0,\n    a: void 0,\n    b: void 0\n  };\n}\nfunction createRegExpNode(id, current) {\n  return {\n    t: 12,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: current.source,\n    m: current.flags,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createArrayBufferNode(id, current) {\n  const bytes = new Uint8Array(current);\n  const len = bytes.length;\n  const values = new Array(len);\n  for (let i = 0; i < len; i++) {\n    values[i] = bytes[i];\n  }\n  return {\n    t: 28,\n    i: id,\n    s: values,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction serializeArrayBuffer(ctx, current) {\n  const id = createIndexedValue(ctx, current);\n  if (ctx.markedRefs.has(id)) {\n    return createIndexedValueNode(id);\n  }\n  return createArrayBufferNode(id, current);\n}\nfunction createTypedArrayNode(ctx, id, current) {\n  const constructor = current.constructor.name;\n  assert(ctx.features & 2048, `Unsupported value type \"${constructor}\"`);\n  return {\n    t: 22,\n    i: id,\n    s: void 0,\n    l: current.length,\n    c: constructor,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: serializeArrayBuffer(ctx, current.buffer),\n    b: current.byteOffset\n  };\n}\nvar BIGINT_FLAG = 4096 | 8;\nfunction createBigIntTypedArrayNode(ctx, id, current) {\n  const constructor = current.constructor.name;\n  assert(\n    (ctx.features & BIGINT_FLAG) === BIGINT_FLAG,\n    `Unsupported value type \"${constructor}\"`\n  );\n  return {\n    t: 23,\n    i: id,\n    s: void 0,\n    l: current.length,\n    c: constructor,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: serializeArrayBuffer(ctx, current.buffer),\n    b: current.byteOffset\n  };\n}\nfunction createWKSymbolNode(ctx, current) {\n  assert(ctx.features & 1024, 'Unsupported type \"symbol\"');\n  assert(current in INV_SYMBOL_REF, \"seroval only supports well-known symbols\");\n  return {\n    t: 24,\n    i: void 0,\n    s: INV_SYMBOL_REF[current],\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createReferenceNode(id, ref) {\n  return {\n    t: 27,\n    i: id,\n    s: serializeString(getReferenceID(ref)),\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction createDataViewNode(ctx, id, current) {\n  return {\n    t: 29,\n    i: id,\n    s: void 0,\n    l: current.byteLength,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: void 0,\n    f: serializeArrayBuffer(ctx, current.buffer),\n    b: current.byteOffset\n  };\n}\nfunction getErrorConstructorName(error) {\n  if (error instanceof EvalError) {\n    return \"EvalError\";\n  }\n  if (error instanceof RangeError) {\n    return \"RangeError\";\n  }\n  if (error instanceof ReferenceError) {\n    return \"ReferenceError\";\n  }\n  if (error instanceof SyntaxError) {\n    return \"SyntaxError\";\n  }\n  if (error instanceof TypeError) {\n    return \"TypeError\";\n  }\n  if (error instanceof URIError) {\n    return \"URIError\";\n  }\n  return \"Error\";\n}\nfunction getErrorConstructor(errorName) {\n  switch (errorName) {\n    case \"Error\":\n      return Error;\n    case \"EvalError\":\n      return EvalError;\n    case \"RangeError\":\n      return RangeError;\n    case \"ReferenceError\":\n      return ReferenceError;\n    case \"SyntaxError\":\n      return SyntaxError;\n    case \"TypeError\":\n      return TypeError;\n    case \"URIError\":\n      return URIError;\n    default:\n      throw new Error(`Unknown Error constructor \"${errorName}\"`);\n  }\n}\nfunction getErrorOptions(ctx, error) {\n  let options;\n  const constructor = getErrorConstructorName(error);\n  if (error.name !== constructor) {\n    options = { name: error.name };\n  } else if (error.constructor.name !== constructor) {\n    options = { name: error.constructor.name };\n  }\n  const names = Object.getOwnPropertyNames(error);\n  for (const name of names) {\n    if (name !== \"name\" && name !== \"message\") {\n      if (name === \"stack\") {\n        if (ctx.features & 16) {\n          options = options || {};\n          options[name] = error[name];\n        }\n      } else {\n        options = options || {};\n        options[name] = error[name];\n      }\n    }\n  }\n  return options;\n}\nfunction getIterableOptions(obj) {\n  const names = Object.getOwnPropertyNames(obj);\n  if (names.length) {\n    const options = {};\n    for (const name of names) {\n      options[name] = obj[name];\n    }\n    return options;\n  }\n  return void 0;\n}\nfunction isIterable(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return false;\n  }\n  switch (value.constructor) {\n    case Map:\n    case Set:\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n    case BigInt64Array:\n    case BigUint64Array:\n      return false;\n    default:\n      break;\n  }\n  return Symbol.iterator in value;\n}\nfunction getTypedArrayConstructor(name) {\n  switch (name) {\n    case \"Int8Array\":\n      return Int8Array;\n    case \"Int16Array\":\n      return Int16Array;\n    case \"Int32Array\":\n      return Int32Array;\n    case \"Uint8Array\":\n      return Uint8Array;\n    case \"Uint16Array\":\n      return Uint16Array;\n    case \"Uint32Array\":\n      return Uint32Array;\n    case \"Uint8ClampedArray\":\n      return Uint8ClampedArray;\n    case \"Float32Array\":\n      return Float32Array;\n    case \"Float64Array\":\n      return Float64Array;\n    case \"BigInt64Array\":\n      return BigInt64Array;\n    case \"BigUint64Array\":\n      return BigUint64Array;\n    default:\n      throw new Error(`Unknown TypedArray \"${name}\"`);\n  }\n}\nvar IDENTIFIER_CHECK = /^[$A-Z_][0-9A-Z_$]*$/i;\nfunction isValidIdentifier(name) {\n  const char = name[0];\n  return (char === \"$\" || char === \"_\" || char >= \"A\" && char <= \"Z\" || char >= \"a\" && char <= \"z\") && IDENTIFIER_CHECK.test(name);\n}\nfunction createURLNode(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"URL\"');\n  return {\n    t: 25,\n    i: id,\n    s: serializeString(current.href),\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    f: void 0,\n    a: void 0,\n    b: void 0\n  };\n}\nfunction createURLSearchParamsNode(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"URLSearchParams\"');\n  return {\n    t: 26,\n    i: id,\n    s: serializeString(current.toString()),\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    f: void 0,\n    a: void 0,\n    b: void 0\n  };\n}\nasync function createBlobNode(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"Blob\"');\n  return {\n    t: 30,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: serializeString(current.type),\n    m: void 0,\n    d: void 0,\n    f: serializeArrayBuffer(ctx, await current.arrayBuffer()),\n    a: void 0,\n    b: void 0\n  };\n}\nasync function createFileNode(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"File\"');\n  return {\n    t: 31,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: serializeString(current.type),\n    m: serializeString(current.name),\n    d: void 0,\n    f: serializeArrayBuffer(ctx, await current.arrayBuffer()),\n    a: void 0,\n    b: current.lastModified\n  };\n}\nasync function generateNodeList(ctx, current) {\n  const size = current.length;\n  const nodes = new Array(size);\n  const deferred = new Array(size);\n  let item;\n  for (let i = 0; i < size; i++) {\n    if (i in current) {\n      item = current[i];\n      if (isIterable(item)) {\n        deferred[i] = item;\n      } else {\n        nodes[i] = await parse(ctx, item);\n      }\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    if (i in deferred) {\n      nodes[i] = await parse(ctx, deferred[i]);\n    }\n  }\n  return nodes;\n}\nasync function generateArrayNode(ctx, id, current) {\n  return {\n    t: 15,\n    i: id,\n    s: void 0,\n    l: current.length,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: await generateNodeList(ctx, current),\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateMapNode(ctx, id, current) {\n  assert(ctx.features & 32, 'Unsupported type \"Map\"');\n  const len = current.size;\n  const keyNodes = new Array(len);\n  const valueNodes = new Array(len);\n  const deferredKey = new Array(len);\n  const deferredValue = new Array(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const [key, value] of current.entries()) {\n    if (isIterable(key) || isIterable(value)) {\n      deferredKey[deferredSize] = key;\n      deferredValue[deferredSize] = value;\n      deferredSize++;\n    } else {\n      keyNodes[nodeSize] = await parse(ctx, key);\n      valueNodes[nodeSize] = await parse(ctx, value);\n      nodeSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodeSize + i] = await parse(ctx, deferredKey[i]);\n    valueNodes[nodeSize + i] = await parse(ctx, deferredValue[i]);\n  }\n  return {\n    t: 14,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: { k: keyNodes, v: valueNodes, s: len },\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateSetNode(ctx, id, current) {\n  assert(ctx.features & 512, 'Unsupported type \"Set\"');\n  const len = current.size;\n  const nodes = new Array(len);\n  const deferred = new Array(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const item of current.keys()) {\n    if (isIterable(item)) {\n      deferred[deferredSize++] = item;\n    } else {\n      nodes[nodeSize++] = await parse(ctx, item);\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    nodes[nodeSize + i] = await parse(ctx, deferred[i]);\n  }\n  return {\n    t: 13,\n    i: id,\n    s: void 0,\n    l: len,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: nodes,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateProperties(ctx, properties) {\n  const keys = Object.keys(properties);\n  const size = keys.length;\n  const keyNodes = new Array(size);\n  const valueNodes = new Array(size);\n  const deferredKeys = new Array(size);\n  const deferredValues = new Array(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item;\n  let escaped;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = await parse(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = await parse(ctx, deferredValues[i]);\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size\n  };\n}\nasync function generateIterableNode(ctx, id, current) {\n  assert(ctx.features & 1024, 'Unsupported type \"Iterable\"');\n  const options = getIterableOptions(current);\n  const array = Array.from(current);\n  return {\n    t: 21,\n    i: id,\n    s: void 0,\n    l: array.length,\n    c: void 0,\n    m: void 0,\n    // Parse options first before the items\n    d: options ? await generateProperties(ctx, options) : void 0,\n    a: await generateNodeList(ctx, array),\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generatePromiseNode(ctx, id, current) {\n  assert(ctx.features & 256, 'Unsupported type \"Promise\"');\n  return current.then(async (value) => ({\n    t: 18,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    // Parse options first before the items\n    d: void 0,\n    a: void 0,\n    f: await parse(ctx, value),\n    b: void 0\n  }));\n}\nasync function generateObjectNode(ctx, id, current, empty) {\n  if (Symbol.iterator in current) {\n    return generateIterableNode(ctx, id, current);\n  }\n  if (\"then\" in current && typeof current.then === \"function\") {\n    return generatePromiseNode(ctx, id, current);\n  }\n  return {\n    t: empty ? 17 : 16,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: await generateProperties(ctx, current),\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateAggregateErrorNode(ctx, id, current) {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options ? await generateProperties(ctx, options) : void 0;\n  return {\n    t: 20,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: serializeString(current.message),\n    d: optionsNode,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateErrorNode(ctx, id, current) {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options ? await generateProperties(ctx, options) : void 0;\n  return {\n    t: 19,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: getErrorConstructorName(current),\n    m: serializeString(current.message),\n    d: optionsNode,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateHeadersNode(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"Headers\"');\n  const items = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: 32,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: await generateProperties(ctx, items),\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function generateFormDataNode(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"FormData\"');\n  const items = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: 33,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: await generateProperties(ctx, items),\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nasync function parse(ctx, current) {\n  switch (typeof current) {\n    case \"boolean\":\n      return current ? TRUE_NODE : FALSE_NODE;\n    case \"undefined\":\n      return UNDEFINED_NODE;\n    case \"string\":\n      return createStringNode(current);\n    case \"number\":\n      switch (current) {\n        case Infinity:\n          return INFINITY_NODE;\n        case -Infinity:\n          return NEG_INFINITY_NODE;\n        default:\n          if (current !== current) {\n            return NAN_NODE;\n          }\n          if (Object.is(current, -0)) {\n            return NEG_ZERO_NODE;\n          }\n          return createNumberNode(current);\n      }\n    case \"bigint\":\n      return createBigIntNode(ctx, current);\n    case \"object\": {\n      if (!current) {\n        return NULL_NODE;\n      }\n      const id = createIndexedValue(ctx, current);\n      if (ctx.markedRefs.has(id)) {\n        return createIndexedValueNode(id);\n      }\n      if (hasReferenceID(current)) {\n        return createReferenceNode(id, current);\n      }\n      if (Array.isArray(current)) {\n        return generateArrayNode(ctx, id, current);\n      }\n      switch (current.constructor) {\n        case Date:\n          return createDateNode(id, current);\n        case RegExp:\n          return createRegExpNode(id, current);\n        case Promise:\n          return generatePromiseNode(ctx, id, current);\n        case ArrayBuffer:\n          return createArrayBufferNode(id, current);\n        case Int8Array:\n        case Int16Array:\n        case Int32Array:\n        case Uint8Array:\n        case Uint16Array:\n        case Uint32Array:\n        case Uint8ClampedArray:\n        case Float32Array:\n        case Float64Array:\n          return createTypedArrayNode(ctx, id, current);\n        case BigInt64Array:\n        case BigUint64Array:\n          return createBigIntTypedArrayNode(ctx, id, current);\n        case DataView:\n          return createDataViewNode(ctx, id, current);\n        case Map:\n          return generateMapNode(\n            ctx,\n            id,\n            current\n          );\n        case Set:\n          return generateSetNode(\n            ctx,\n            id,\n            current\n          );\n        case Object:\n          return generateObjectNode(\n            ctx,\n            id,\n            current,\n            false\n          );\n        case void 0:\n          return generateObjectNode(\n            ctx,\n            id,\n            current,\n            true\n          );\n        case AggregateError:\n          if (ctx.features & 1) {\n            return generateAggregateErrorNode(ctx, id, current);\n          }\n          return generateErrorNode(ctx, id, current);\n        case Error:\n        case EvalError:\n        case RangeError:\n        case ReferenceError:\n        case SyntaxError:\n        case TypeError:\n        case URIError:\n          return generateErrorNode(ctx, id, current);\n        case URL:\n          return createURLNode(ctx, id, current);\n        case URLSearchParams:\n          return createURLSearchParamsNode(ctx, id, current);\n        case Blob:\n          return createBlobNode(ctx, id, current);\n        case File:\n          return createFileNode(ctx, id, current);\n        case Headers:\n          return generateHeadersNode(ctx, id, current);\n        case FormData:\n          return generateFormDataNode(ctx, id, current);\n        default:\n          break;\n      }\n      if (current instanceof AggregateError) {\n        if (ctx.features & 1) {\n          return generateAggregateErrorNode(ctx, id, current);\n        }\n        return generateErrorNode(ctx, id, current);\n      }\n      if (current instanceof Error) {\n        return generateErrorNode(ctx, id, current);\n      }\n      if (current instanceof Promise) {\n        return generatePromiseNode(ctx, id, current);\n      }\n      if (Symbol.iterator in current) {\n        return generateIterableNode(ctx, id, current);\n      }\n      if (\"then\" in current && typeof current.then === \"function\") {\n        return generatePromiseNode(ctx, id, current);\n      }\n      throw new Error(\"Unsupported type\");\n    }\n    case \"symbol\":\n      if (hasReferenceID(current)) {\n        const id = createIndexedValue(ctx, current);\n        if (ctx.markedRefs.has(id)) {\n          return createIndexedValueNode(id);\n        }\n        return createReferenceNode(id, current);\n      }\n      return createWKSymbolNode(ctx, current);\n    case \"function\": {\n      assert(hasReferenceID(current), \"Cannot serialize function without reference ID.\");\n      const id = createIndexedValue(ctx, current);\n      if (ctx.markedRefs.has(id)) {\n        return createIndexedValueNode(id);\n      }\n      return createReferenceNode(id, current);\n    }\n    default:\n      throw new Error(\"Unsupported type\");\n  }\n}\nasync function parseAsync(ctx, current) {\n  const result = await parse(ctx, current);\n  const isObject = result.t === 16 || result.t === 21;\n  return [result, getRootID(ctx, current), isObject];\n}\nfunction assignIndexedValue(ctx, index, value) {\n  if (ctx.markedRefs.has(index)) {\n    ctx.valueMap.set(index, value);\n  }\n  return value;\n}\nfunction deserializeArray(ctx, node) {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new Array(node.l)\n  );\n  let item;\n  for (let i = 0, len = node.l; i < len; i++) {\n    item = node.a[i];\n    if (item) {\n      result[i] = deserializeTree(ctx, item);\n    }\n  }\n  return result;\n}\nfunction deserializeProperties(ctx, node, result) {\n  if (node.s === 0) {\n    return {};\n  }\n  for (let i = 0; i < node.s; i++) {\n    result[deserializeString(node.k[i])] = deserializeTree(ctx, node.v[i]);\n  }\n  return result;\n}\nfunction deserializeNullConstructor(ctx, node) {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    /* @__PURE__ */ Object.create(null)\n  );\n  deserializeProperties(ctx, node.d, result);\n  return result;\n}\nfunction deserializeObject(ctx, node) {\n  const result = assignIndexedValue(ctx, node.i, {});\n  deserializeProperties(ctx, node.d, result);\n  return result;\n}\nfunction deserializeSet(ctx, node) {\n  const result = assignIndexedValue(ctx, node.i, /* @__PURE__ */ new Set());\n  for (let i = 0, len = node.l; i < len; i++) {\n    result.add(deserializeTree(ctx, node.a[i]));\n  }\n  return result;\n}\nfunction deserializeMap(ctx, node) {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    /* @__PURE__ */ new Map()\n  );\n  for (let i = 0, len = node.d.s; i < len; i++) {\n    result.set(\n      deserializeTree(ctx, node.d.k[i]),\n      deserializeTree(ctx, node.d.v[i])\n    );\n  }\n  return result;\n}\nfunction deserializeDictionary(ctx, node, result) {\n  if (node.d) {\n    const fields = deserializeProperties(ctx, node.d, {});\n    Object.assign(result, fields);\n  }\n  return result;\n}\nfunction deserializeAggregateError(ctx, node) {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new AggregateError([], deserializeString(node.m))\n  );\n  return deserializeDictionary(ctx, node, result);\n}\nfunction deserializeError(ctx, node) {\n  const ErrorConstructor = getErrorConstructor(node.c);\n  const result = assignIndexedValue(ctx, node.i, new ErrorConstructor(deserializeString(node.m)));\n  return deserializeDictionary(ctx, node, result);\n}\nfunction createDeferred() {\n  let resolver;\n  return {\n    resolve(v) {\n      resolver(v);\n    },\n    promise: new Promise((res) => {\n      resolver = res;\n    })\n  };\n}\nfunction deserializePromise(ctx, node) {\n  const deferred = createDeferred();\n  const result = assignIndexedValue(ctx, node.i, deferred.promise);\n  deferred.resolve(deserializeTree(ctx, node.f));\n  return result;\n}\nfunction deserializeArrayBuffer(ctx, node) {\n  const bytes = new Uint8Array(node.s);\n  const result = assignIndexedValue(ctx, node.i, bytes.buffer);\n  return result;\n}\nfunction deserializeTypedArray(ctx, node) {\n  const TypedArray = getTypedArrayConstructor(node.c);\n  const source = deserializeTree(ctx, node.f);\n  const result = assignIndexedValue(ctx, node.i, new TypedArray(\n    source,\n    node.b,\n    node.l\n  ));\n  return result;\n}\nfunction deserializeIterable(ctx, node) {\n  const values = [];\n  let item;\n  for (let i = 0, len = node.l; i < len; i++) {\n    item = node.a[i];\n    if (item) {\n      values[i] = deserializeTree(ctx, item);\n    }\n  }\n  const result = assignIndexedValue(ctx, node.i, {\n    [Symbol.iterator]: () => values.values()\n  });\n  return deserializeDictionary(ctx, node, result);\n}\nfunction deserializeDate(ctx, node) {\n  return assignIndexedValue(ctx, node.i, new Date(node.s));\n}\nfunction deserializeRegExp(ctx, node) {\n  return assignIndexedValue(ctx, node.i, new RegExp(node.c, node.m));\n}\nfunction deserializeURL(ctx, node) {\n  return assignIndexedValue(ctx, node.i, new URL(deserializeString(node.s)));\n}\nfunction deserializeURLSearchParams(ctx, node) {\n  return assignIndexedValue(ctx, node.i, new URLSearchParams(deserializeString(node.s)));\n}\nfunction deserializeReference(ctx, node) {\n  return assignIndexedValue(ctx, node.i, getReference(deserializeString(node.s)));\n}\nfunction deserializeDataView(ctx, node) {\n  const source = deserializeTree(ctx, node.f);\n  const result = assignIndexedValue(ctx, node.i, new DataView(\n    source,\n    node.b,\n    node.l\n  ));\n  return result;\n}\nfunction deserializeBlob(ctx, node) {\n  const source = deserializeTree(ctx, node.f);\n  const result = assignIndexedValue(ctx, node.i, new Blob(\n    [source],\n    { type: deserializeString(node.c) }\n  ));\n  return result;\n}\nfunction deserializeFile(ctx, node) {\n  const source = deserializeTree(ctx, node.f);\n  const result = assignIndexedValue(ctx, node.i, new File(\n    [source],\n    deserializeString(node.m),\n    { type: deserializeString(node.c), lastModified: node.b }\n  ));\n  return result;\n}\nfunction deserializeHeaders(ctx, node) {\n  const result = assignIndexedValue(ctx, node.i, new Headers());\n  for (let i = 0, len = node.d.s; i < len; i++) {\n    result.set(\n      deserializeString(node.d.k[i]),\n      deserializeTree(ctx, node.d.v[i])\n    );\n  }\n  return result;\n}\nfunction deserializeFormData(ctx, node) {\n  const result = assignIndexedValue(ctx, node.i, new FormData());\n  for (let i = 0, len = node.d.s; i < len; i++) {\n    result.set(\n      deserializeString(node.d.k[i]),\n      deserializeTree(ctx, node.d.v[i])\n    );\n  }\n  return result;\n}\nfunction deserializeTree(ctx, node) {\n  switch (node.t) {\n    case 0:\n    case 2:\n      return node.s;\n    case 1:\n      return deserializeString(node.s);\n    case 4:\n      return void 0;\n    case 3:\n      return null;\n    case 5:\n      return -0;\n    case 6:\n      return Infinity;\n    case 7:\n      return -Infinity;\n    case 8:\n      return NaN;\n    case 9:\n      return BigInt(node.s);\n    case 10:\n      return ctx.valueMap.get(node.i);\n    case 15:\n      return deserializeArray(ctx, node);\n    case 16:\n      return deserializeObject(ctx, node);\n    case 17:\n      return deserializeNullConstructor(ctx, node);\n    case 11:\n      return deserializeDate(ctx, node);\n    case 12:\n      return deserializeRegExp(ctx, node);\n    case 13:\n      return deserializeSet(ctx, node);\n    case 14:\n      return deserializeMap(ctx, node);\n    case 28:\n      return deserializeArrayBuffer(ctx, node);\n    case 23:\n    case 22:\n      return deserializeTypedArray(ctx, node);\n    case 29:\n      return deserializeDataView(ctx, node);\n    case 20:\n      return deserializeAggregateError(ctx, node);\n    case 19:\n      return deserializeError(ctx, node);\n    case 21:\n      return deserializeIterable(ctx, node);\n    case 18:\n      return deserializePromise(ctx, node);\n    case 24:\n      return SYMBOL_REF[node.s];\n    case 25:\n      return deserializeURL(ctx, node);\n    case 26:\n      return deserializeURLSearchParams(ctx, node);\n    case 27:\n      return deserializeReference(ctx, node);\n    case 30:\n      return deserializeBlob(ctx, node);\n    case 31:\n      return deserializeFile(ctx, node);\n    case 32:\n      return deserializeHeaders(ctx, node);\n    case 33:\n      return deserializeFormData(ctx, node);\n    default:\n      throw new Error(\"Unsupported type\");\n  }\n}\nfunction getAssignmentExpression(assignment) {\n  switch (assignment.t) {\n    case \"index\":\n      return assignment.s + \"=\" + assignment.v;\n    case \"set\":\n      return assignment.s + \".set(\" + assignment.k + \",\" + assignment.v + \")\";\n    case \"add\":\n      return assignment.s + \".add(\" + assignment.v + \")\";\n    case \"append\":\n      return assignment.s + \".append(\" + assignment.k + \",\" + assignment.v + \")\";\n    default:\n      return \"\";\n  }\n}\nfunction mergeAssignments(assignments) {\n  const newAssignments = [];\n  let current = assignments[0];\n  let prev = current;\n  let item;\n  for (let i = 1, len = assignments.length; i < len; i++) {\n    item = assignments[i];\n    if (item.t === prev.t) {\n      switch (item.t) {\n        case \"index\":\n          if (item.v === prev.v) {\n            current = {\n              t: \"index\",\n              s: item.s,\n              k: void 0,\n              v: getAssignmentExpression(current)\n            };\n          } else {\n            newAssignments.push(current);\n            current = item;\n          }\n          break;\n        case \"set\":\n          if (item.s === prev.s) {\n            current = {\n              t: \"set\",\n              s: getAssignmentExpression(current),\n              k: item.k,\n              v: item.v\n            };\n          } else {\n            newAssignments.push(current);\n            current = item;\n          }\n          break;\n        case \"add\":\n          if (item.s === prev.s) {\n            current = {\n              t: \"add\",\n              s: getAssignmentExpression(current),\n              k: void 0,\n              v: item.v\n            };\n          } else {\n            newAssignments.push(current);\n            current = item;\n          }\n          break;\n        case \"append\":\n          newAssignments.push(current);\n          current = item;\n          break;\n        default:\n          break;\n      }\n    } else {\n      newAssignments.push(current);\n      current = item;\n    }\n    prev = item;\n  }\n  newAssignments.push(current);\n  return newAssignments;\n}\nfunction resolveAssignments(assignments) {\n  if (assignments.length) {\n    let result = \"\";\n    const merged = mergeAssignments(assignments);\n    for (let i = 0, len = merged.length; i < len; i++) {\n      result += getAssignmentExpression(merged[i]) + \",\";\n    }\n    return result;\n  }\n  return void 0;\n}\nfunction resolvePatches(ctx) {\n  return resolveAssignments(ctx.assignments);\n}\nfunction createAssignment(ctx, source, value) {\n  ctx.assignments.push({\n    t: \"index\",\n    s: source,\n    k: void 0,\n    v: value\n  });\n}\nfunction createAddAssignment(ctx, ref, value) {\n  ctx.assignments.push({\n    t: \"add\",\n    s: getRefParam(ctx, ref),\n    k: void 0,\n    v: value\n  });\n}\nfunction createSetAssignment(ctx, ref, key, value) {\n  ctx.assignments.push({\n    t: \"set\",\n    s: getRefParam(ctx, ref),\n    k: key,\n    v: value\n  });\n}\nfunction createAppendAssignment(ctx, ref, key, value) {\n  ctx.assignments.push({\n    t: \"append\",\n    s: getRefParam(ctx, ref),\n    k: key,\n    v: value\n  });\n}\nfunction createArrayAssign(ctx, ref, index, value) {\n  createAssignment(ctx, getRefParam(ctx, ref) + \"[\" + index + \"]\", value);\n}\nfunction createObjectAssign(ctx, ref, key, value) {\n  markRef(ctx, ref);\n  createAssignment(ctx, getRefParam(ctx, ref) + \".\" + key, value);\n}\nfunction assignIndexedValue2(ctx, index, value) {\n  if (ctx.markedRefs.has(index)) {\n    return getRefParam(ctx, index) + \"=\" + value;\n  }\n  return value;\n}\nfunction isIndexedValueInStack(ctx, node) {\n  return node.t === 10 && ctx.stack.includes(node.i);\n}\nfunction serializeNodeList(ctx, node) {\n  const size = node.l;\n  let values = \"\";\n  let item;\n  let isHoley = false;\n  for (let i = 0; i < size; i++) {\n    if (i !== 0) {\n      values += \",\";\n    }\n    item = node.a[i];\n    if (item) {\n      if (isIndexedValueInStack(ctx, item)) {\n        markRef(ctx, node.i);\n        createArrayAssign(ctx, node.i, i, getRefParam(ctx, item.i));\n        isHoley = true;\n      } else {\n        values += serializeTree(ctx, item);\n        isHoley = false;\n      }\n    } else {\n      isHoley = true;\n    }\n  }\n  return \"[\" + values + (isHoley ? \",]\" : \"]\");\n}\nfunction serializeArray(ctx, node) {\n  ctx.stack.push(node.i);\n  const result = serializeNodeList(ctx, node);\n  ctx.stack.pop();\n  return assignIndexedValue2(ctx, node.i, result);\n}\nfunction serializeProperties(ctx, sourceID, node) {\n  if (node.s === 0) {\n    return \"{}\";\n  }\n  let result = \"\";\n  ctx.stack.push(sourceID);\n  let key;\n  let val;\n  let check;\n  let isIdentifier;\n  let refParam;\n  let hasPrev = false;\n  const keys = node.k;\n  const values = node.v;\n  for (let i = 0, len = node.s; i < len; i++) {\n    key = keys[i];\n    val = values[i];\n    check = Number(key);\n    isIdentifier = check >= 0 || isValidIdentifier(key);\n    if (isIndexedValueInStack(ctx, val)) {\n      refParam = getRefParam(ctx, val.i);\n      if (isIdentifier && Number.isNaN(check)) {\n        markRef(ctx, sourceID);\n        createObjectAssign(ctx, sourceID, key, refParam);\n      } else {\n        markRef(ctx, sourceID);\n        createArrayAssign(ctx, sourceID, isIdentifier ? key : '\"' + key + '\"', refParam);\n      }\n    } else {\n      result += (hasPrev ? \",\" : \"\") + (isIdentifier ? key : '\"' + key + '\"') + \":\" + serializeTree(ctx, val);\n      hasPrev = true;\n    }\n  }\n  ctx.stack.pop();\n  return \"{\" + result + \"}\";\n}\nfunction serializeWithObjectAssign(ctx, value, id, serialized) {\n  const fields = serializeProperties(ctx, id, value);\n  if (fields !== \"{}\") {\n    return \"Object.assign(\" + serialized + \",\" + fields + \")\";\n  }\n  return serialized;\n}\nfunction serializeAssignments(ctx, sourceID, node) {\n  ctx.stack.push(sourceID);\n  const mainAssignments = [];\n  let parentStack;\n  let refParam;\n  let key;\n  let check;\n  let parentAssignment;\n  let isIdentifier;\n  const keys = node.k;\n  const values = node.v;\n  for (let i = 0, len = node.s; i < len; i++) {\n    parentStack = ctx.stack;\n    ctx.stack = [];\n    refParam = serializeTree(ctx, values[i]);\n    ctx.stack = parentStack;\n    key = keys[i];\n    check = Number(key);\n    parentAssignment = ctx.assignments;\n    ctx.assignments = mainAssignments;\n    isIdentifier = check >= 0 || isValidIdentifier(key);\n    if (isIdentifier && Number.isNaN(check)) {\n      createObjectAssign(ctx, sourceID, key, refParam);\n    } else {\n      createArrayAssign(ctx, sourceID, isIdentifier ? key : '\"' + key + '\"', refParam);\n    }\n    ctx.assignments = parentAssignment;\n  }\n  ctx.stack.pop();\n  return resolveAssignments(mainAssignments);\n}\nfunction serializeDictionary(ctx, i, d, init) {\n  if (d) {\n    if (ctx.features & 128) {\n      init = serializeWithObjectAssign(ctx, d, i, init);\n    } else {\n      markRef(ctx, i);\n      const assignments = serializeAssignments(ctx, i, d);\n      if (assignments) {\n        return \"(\" + assignIndexedValue2(ctx, i, init) + \",\" + assignments + getRefParam(ctx, i) + \")\";\n      }\n    }\n  }\n  return assignIndexedValue2(ctx, i, init);\n}\nfunction serializeNullConstructor(ctx, node) {\n  return serializeDictionary(ctx, node.i, node.d, \"Object.create(null)\");\n}\nfunction serializeObject(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, serializeProperties(ctx, node.i, node.d));\n}\nfunction serializeSet(ctx, node) {\n  let serialized = \"new Set\";\n  const size = node.l;\n  if (size) {\n    let result = \"\";\n    ctx.stack.push(node.i);\n    let item;\n    let hasPrev = false;\n    for (let i = 0; i < size; i++) {\n      item = node.a[i];\n      if (isIndexedValueInStack(ctx, item)) {\n        markRef(ctx, node.i);\n        createAddAssignment(ctx, node.i, getRefParam(ctx, item.i));\n      } else {\n        result += (hasPrev ? \",\" : \"\") + serializeTree(ctx, item);\n        hasPrev = true;\n      }\n    }\n    ctx.stack.pop();\n    if (result) {\n      serialized += \"([\" + result + \"])\";\n    }\n  }\n  return assignIndexedValue2(ctx, node.i, serialized);\n}\nfunction serializeMap(ctx, node) {\n  let serialized = \"new Map\";\n  if (node.d.s) {\n    let result = \"\";\n    ctx.stack.push(node.i);\n    let key;\n    let val;\n    let keyRef;\n    let valueRef;\n    let parent;\n    let hasPrev = false;\n    for (let i = 0; i < node.d.s; i++) {\n      key = node.d.k[i];\n      val = node.d.v[i];\n      if (isIndexedValueInStack(ctx, key)) {\n        keyRef = getRefParam(ctx, key.i);\n        markRef(ctx, node.i);\n        if (isIndexedValueInStack(ctx, val)) {\n          valueRef = getRefParam(ctx, val.i);\n          createSetAssignment(ctx, node.i, keyRef, valueRef);\n        } else {\n          parent = ctx.stack;\n          ctx.stack = [];\n          createSetAssignment(ctx, node.i, keyRef, serializeTree(ctx, val));\n          ctx.stack = parent;\n        }\n      } else if (isIndexedValueInStack(ctx, val)) {\n        valueRef = getRefParam(ctx, val.i);\n        markRef(ctx, node.i);\n        parent = ctx.stack;\n        ctx.stack = [];\n        createSetAssignment(ctx, node.i, serializeTree(ctx, key), valueRef);\n        ctx.stack = parent;\n      } else {\n        result += (hasPrev ? \",[\" : \"[\") + serializeTree(ctx, key) + \",\" + serializeTree(ctx, val) + \"]\";\n        hasPrev = true;\n      }\n    }\n    ctx.stack.pop();\n    if (result) {\n      serialized += \"([\" + result + \"])\";\n    }\n  }\n  return assignIndexedValue2(ctx, node.i, serialized);\n}\nfunction serializeAggregateError(ctx, node) {\n  ctx.stack.push(node.i);\n  const serialized = 'new AggregateError([],\"' + node.m + '\")';\n  ctx.stack.pop();\n  return serializeDictionary(ctx, node.i, node.d, serialized);\n}\nfunction serializeError(ctx, node) {\n  const serialized = \"new \" + node.c + '(\"' + node.m + '\")';\n  return serializeDictionary(ctx, node.i, node.d, serialized);\n}\nfunction serializePromise(ctx, node) {\n  let serialized;\n  if (isIndexedValueInStack(ctx, node.f)) {\n    const ref = getRefParam(ctx, node.f.i);\n    if (ctx.features & 4) {\n      serialized = \"Promise.resolve().then(()=>\" + ref + \")\";\n    } else {\n      serialized = \"Promise.resolve().then(function(){return \" + ref + \"})\";\n    }\n  } else {\n    ctx.stack.push(node.i);\n    const result = serializeTree(ctx, node.f);\n    ctx.stack.pop();\n    serialized = \"Promise.resolve(\" + result + \")\";\n  }\n  return assignIndexedValue2(ctx, node.i, serialized);\n}\nfunction serializeArrayBuffer2(ctx, node) {\n  let result = \"new Uint8Array(\";\n  if (node.s.length) {\n    result += \"[\";\n    for (let i = 0, len = node.s.length; i < len; i++) {\n      result += (i > 0 ? \",\" : \"\") + node.s[i];\n    }\n    result += \"]\";\n  }\n  return assignIndexedValue2(ctx, node.i, result + \").buffer\");\n}\nfunction serializeTypedArray(ctx, node) {\n  const args = serializeTree(ctx, node.f) + \",\" + node.b + \",\" + node.l;\n  return assignIndexedValue2(ctx, node.i, \"new \" + node.c + \"(\" + args + \")\");\n}\nfunction serializeIterable(ctx, node) {\n  const parent = ctx.stack;\n  ctx.stack = [];\n  const values = serializeNodeList(ctx, node);\n  ctx.stack = parent;\n  let serialized = values;\n  if (ctx.features & 2) {\n    serialized += \".values()\";\n  } else {\n    serialized += \"[Symbol.iterator]()\";\n  }\n  if (ctx.features & 4) {\n    serialized = \"{[Symbol.iterator]:()=>\" + serialized + \"}\";\n  } else if (ctx.features & 64) {\n    serialized = \"{[Symbol.iterator](){return \" + serialized + \"}}\";\n  } else {\n    serialized = \"{[Symbol.iterator]:function(){return \" + serialized + \"}}\";\n  }\n  return serializeDictionary(ctx, node.i, node.d, serialized);\n}\nfunction serializeDate(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, 'new Date(\"' + node.s + '\")');\n}\nfunction serializeRegExp(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, \"/\" + node.c + \"/\" + node.m);\n}\nfunction serializeURL(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, 'new URL(\"' + node.s + '\")');\n}\nfunction serializeURLSearchParams(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, node.s ? 'new URLSearchParams(\"' + node.s + '\")' : \"new URLSearchParams\");\n}\nfunction serializeReference(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, GLOBAL_KEY + '.get(\"' + node.s + '\")');\n}\nfunction serializeDataView(ctx, node) {\n  const args = serializeTree(ctx, node.f) + \",\" + node.b + \",\" + node.l;\n  return assignIndexedValue2(ctx, node.i, \"new DataView(\" + args + \")\");\n}\nfunction serializeBlob(ctx, node) {\n  const args = \"[\" + serializeTree(ctx, node.f) + '],{type:\"' + node.c + '\"}';\n  return assignIndexedValue2(ctx, node.i, \"new Blob(\" + args + \")\");\n}\nfunction serializeFile(ctx, node) {\n  const options = '{type:\"' + node.c + '\",lastModified:' + node.b + \"}\";\n  const args = \"[\" + serializeTree(ctx, node.f) + '],\"' + node.m + '\",' + options;\n  return assignIndexedValue2(ctx, node.i, \"new File(\" + args + \")\");\n}\nfunction serializeHeaders(ctx, node) {\n  return assignIndexedValue2(ctx, node.i, \"new Headers(\" + serializeProperties(ctx, node.i, node.d) + \")\");\n}\nfunction serializeFormDataEntries(ctx, node) {\n  ctx.stack.push(node.i);\n  const mainAssignments = [];\n  let parentStack;\n  let value;\n  let key;\n  let parentAssignment;\n  for (let i = 0; i < node.d.s; i++) {\n    parentStack = ctx.stack;\n    ctx.stack = [];\n    value = serializeTree(ctx, node.d.v[i]);\n    key = node.d.k[i];\n    ctx.stack = parentStack;\n    parentAssignment = ctx.assignments;\n    ctx.assignments = mainAssignments;\n    createAppendAssignment(ctx, node.i, '\"' + key + '\"', value);\n    ctx.assignments = parentAssignment;\n  }\n  ctx.stack.pop();\n  return resolveAssignments(mainAssignments);\n}\nfunction serializeFormData(ctx, node) {\n  if (node.d.s) {\n    markRef(ctx, node.i);\n  }\n  const result = assignIndexedValue2(ctx, node.i, \"new FormData()\");\n  if (node.d.s) {\n    return \"(\" + result + \",\" + serializeFormDataEntries(ctx, node) + getRefParam(ctx, node.i) + \")\";\n  }\n  return result;\n}\nfunction serializeTree(ctx, node) {\n  switch (node.t) {\n    case 0:\n      return \"\" + node.s;\n    case 1:\n      return '\"' + node.s + '\"';\n    case 2:\n      return node.s ? \"!0\" : \"!1\";\n    case 4:\n      return \"void 0\";\n    case 3:\n      return \"null\";\n    case 5:\n      return \"-0\";\n    case 6:\n      return \"1/0\";\n    case 7:\n      return \"-1/0\";\n    case 8:\n      return \"NaN\";\n    case 9:\n      return node.s + \"n\";\n    case 10:\n      return getRefParam(ctx, node.i);\n    case 15:\n      return serializeArray(ctx, node);\n    case 16:\n      return serializeObject(ctx, node);\n    case 17:\n      return serializeNullConstructor(ctx, node);\n    case 11:\n      return serializeDate(ctx, node);\n    case 12:\n      return serializeRegExp(ctx, node);\n    case 13:\n      return serializeSet(ctx, node);\n    case 14:\n      return serializeMap(ctx, node);\n    case 28:\n      return serializeArrayBuffer2(ctx, node);\n    case 23:\n    case 22:\n      return serializeTypedArray(ctx, node);\n    case 29:\n      return serializeDataView(ctx, node);\n    case 20:\n      return serializeAggregateError(ctx, node);\n    case 19:\n      return serializeError(ctx, node);\n    case 21:\n      return serializeIterable(ctx, node);\n    case 18:\n      return serializePromise(ctx, node);\n    case 24:\n      return SYMBOL_STRING[node.s];\n    case 25:\n      return serializeURL(ctx, node);\n    case 26:\n      return serializeURLSearchParams(ctx, node);\n    case 27:\n      return serializeReference(ctx, node);\n    case 30:\n      return serializeBlob(ctx, node);\n    case 31:\n      return serializeFile(ctx, node);\n    case 32:\n      return serializeHeaders(ctx, node);\n    case 33:\n      return serializeFormData(ctx, node);\n    default:\n      throw new Error(\"Unsupported type\");\n  }\n}\nfunction generateNodeList2(ctx, current) {\n  const size = current.length;\n  const nodes = new Array(size);\n  const deferred = new Array(size);\n  let item;\n  for (let i = 0; i < size; i++) {\n    if (i in current) {\n      item = current[i];\n      if (isIterable(item)) {\n        deferred[i] = item;\n      } else {\n        nodes[i] = parse2(ctx, item);\n      }\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    if (i in deferred) {\n      nodes[i] = parse2(ctx, deferred[i]);\n    }\n  }\n  return nodes;\n}\nfunction generateArrayNode2(ctx, id, current) {\n  return {\n    t: 15,\n    i: id,\n    s: void 0,\n    l: current.length,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: generateNodeList2(ctx, current),\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateMapNode2(ctx, id, current) {\n  assert(ctx.features & 32, 'Unsupported type \"Map\"');\n  const len = current.size;\n  const keyNodes = new Array(len);\n  const valueNodes = new Array(len);\n  const deferredKey = new Array(len);\n  const deferredValue = new Array(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const [key, value] of current.entries()) {\n    if (isIterable(key) || isIterable(value)) {\n      deferredKey[deferredSize] = key;\n      deferredValue[deferredSize] = value;\n      deferredSize++;\n    } else {\n      keyNodes[nodeSize] = parse2(ctx, key);\n      valueNodes[nodeSize] = parse2(ctx, value);\n      nodeSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodeSize + i] = parse2(ctx, deferredKey[i]);\n    valueNodes[nodeSize + i] = parse2(ctx, deferredValue[i]);\n  }\n  return {\n    t: 14,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: { k: keyNodes, v: valueNodes, s: len },\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateSetNode2(ctx, id, current) {\n  assert(ctx.features & 512, 'Unsupported type \"Set\"');\n  const len = current.size;\n  const nodes = new Array(len);\n  const deferred = new Array(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const item of current.keys()) {\n    if (isIterable(item)) {\n      deferred[deferredSize++] = item;\n    } else {\n      nodes[nodeSize++] = parse2(ctx, item);\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    nodes[nodeSize + i] = parse2(ctx, deferred[i]);\n  }\n  return {\n    t: 13,\n    i: id,\n    s: void 0,\n    l: len,\n    c: void 0,\n    m: void 0,\n    d: void 0,\n    a: nodes,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateProperties2(ctx, properties) {\n  const keys = Object.keys(properties);\n  const size = keys.length;\n  const keyNodes = new Array(size);\n  const valueNodes = new Array(size);\n  const deferredKeys = new Array(size);\n  const deferredValues = new Array(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item;\n  let escaped;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = parse2(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = parse2(ctx, deferredValues[i]);\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size\n  };\n}\nfunction generateIterableNode2(ctx, id, current) {\n  assert(ctx.features & 1024, 'Unsupported type \"Iterable\"');\n  const options = getIterableOptions(current);\n  const array = Array.from(current);\n  return {\n    t: 21,\n    i: id,\n    s: void 0,\n    l: array.length,\n    c: void 0,\n    m: void 0,\n    // Parse options first before the items\n    d: options ? generateProperties2(ctx, options) : void 0,\n    a: generateNodeList2(ctx, array),\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateObjectNode2(ctx, id, current, empty) {\n  if (Symbol.iterator in current) {\n    return generateIterableNode2(ctx, id, current);\n  }\n  return {\n    t: empty ? 17 : 16,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: generateProperties2(ctx, current),\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateAggregateErrorNode2(ctx, id, current) {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options ? generateProperties2(ctx, options) : void 0;\n  return {\n    t: 20,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: serializeString(current.message),\n    d: optionsNode,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateErrorNode2(ctx, id, current) {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options ? generateProperties2(ctx, options) : void 0;\n  return {\n    t: 19,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: getErrorConstructorName(current),\n    m: serializeString(current.message),\n    d: optionsNode,\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateHeadersNode2(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"Headers\"');\n  const items = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: 32,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: generateProperties2(ctx, items),\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction generateFormDataNode2(ctx, id, current) {\n  assert(ctx.features & 8192, 'Unsupported type \"FormData\"');\n  const items = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: 33,\n    i: id,\n    s: void 0,\n    l: void 0,\n    c: void 0,\n    m: void 0,\n    d: generateProperties2(ctx, items),\n    a: void 0,\n    f: void 0,\n    b: void 0\n  };\n}\nfunction parse2(ctx, current) {\n  switch (typeof current) {\n    case \"boolean\":\n      return current ? TRUE_NODE : FALSE_NODE;\n    case \"undefined\":\n      return UNDEFINED_NODE;\n    case \"string\":\n      return createStringNode(current);\n    case \"number\":\n      switch (current) {\n        case Infinity:\n          return INFINITY_NODE;\n        case -Infinity:\n          return NEG_INFINITY_NODE;\n        default:\n          if (current !== current) {\n            return NAN_NODE;\n          }\n          if (Object.is(current, -0)) {\n            return NEG_ZERO_NODE;\n          }\n          return createNumberNode(current);\n      }\n    case \"bigint\":\n      return createBigIntNode(ctx, current);\n    case \"object\": {\n      if (!current) {\n        return NULL_NODE;\n      }\n      const id = createIndexedValue(ctx, current);\n      if (ctx.markedRefs.has(id)) {\n        return createIndexedValueNode(id);\n      }\n      if (hasReferenceID(current)) {\n        return createReferenceNode(id, current);\n      }\n      if (Array.isArray(current)) {\n        return generateArrayNode2(ctx, id, current);\n      }\n      switch (current.constructor) {\n        case Date:\n          return createDateNode(id, current);\n        case RegExp:\n          return createRegExpNode(id, current);\n        case ArrayBuffer:\n          return createArrayBufferNode(id, current);\n        case Int8Array:\n        case Int16Array:\n        case Int32Array:\n        case Uint8Array:\n        case Uint16Array:\n        case Uint32Array:\n        case Uint8ClampedArray:\n        case Float32Array:\n        case Float64Array:\n          return createTypedArrayNode(ctx, id, current);\n        case BigInt64Array:\n        case BigUint64Array:\n          return createBigIntTypedArrayNode(ctx, id, current);\n        case DataView:\n          return createDataViewNode(ctx, id, current);\n        case Map:\n          return generateMapNode2(ctx, id, current);\n        case Set:\n          return generateSetNode2(ctx, id, current);\n        case Object:\n          return generateObjectNode2(\n            ctx,\n            id,\n            current,\n            false\n          );\n        case void 0:\n          return generateObjectNode2(\n            ctx,\n            id,\n            current,\n            true\n          );\n        case AggregateError:\n          if (ctx.features & 1) {\n            return generateAggregateErrorNode2(ctx, id, current);\n          }\n          return generateErrorNode2(ctx, id, current);\n        case Error:\n        case EvalError:\n        case RangeError:\n        case ReferenceError:\n        case SyntaxError:\n        case TypeError:\n        case URIError:\n          return generateErrorNode2(ctx, id, current);\n        case URL:\n          return createURLNode(ctx, id, current);\n        case URLSearchParams:\n          return createURLSearchParamsNode(ctx, id, current);\n        case Headers:\n          return generateHeadersNode2(ctx, id, current);\n        case FormData:\n          return generateFormDataNode2(ctx, id, current);\n        default:\n          break;\n      }\n      if (current instanceof AggregateError) {\n        if (ctx.features & 1) {\n          return generateAggregateErrorNode2(ctx, id, current);\n        }\n        return generateErrorNode2(ctx, id, current);\n      }\n      if (current instanceof Error) {\n        return generateErrorNode2(ctx, id, current);\n      }\n      if (Symbol.iterator in current) {\n        return generateIterableNode2(ctx, id, current);\n      }\n      throw new Error(\"Unsupported type\");\n    }\n    case \"symbol\":\n      if (hasReferenceID(current)) {\n        const id = createIndexedValue(ctx, current);\n        if (ctx.markedRefs.has(id)) {\n          return createIndexedValueNode(id);\n        }\n        return createReferenceNode(id, current);\n      }\n      return createWKSymbolNode(ctx, current);\n    case \"function\": {\n      assert(hasReferenceID(current), \"Cannot serialize function without reference ID.\");\n      const id = createIndexedValue(ctx, current);\n      if (ctx.markedRefs.has(id)) {\n        return createIndexedValueNode(id);\n      }\n      return createReferenceNode(id, current);\n    }\n    default:\n      throw new Error(\"Unsupported type\");\n  }\n}\nfunction parseSync(ctx, current) {\n  const result = parse2(ctx, current);\n  const isObject = result.t === 16 || result.t === 21;\n  return [result, getRootID(ctx, current), isObject];\n}\nfunction finalize(ctx, rootID, isObject, result) {\n  if (ctx.vars.length) {\n    const patches = resolvePatches(ctx);\n    let body = result;\n    if (patches) {\n      const index = getRefParam(ctx, rootID);\n      body = result + \",\" + patches + index;\n      if (!result.startsWith(index + \"=\")) {\n        body = index + \"=\" + body;\n      }\n    }\n    let params = ctx.vars.length > 1 ? ctx.vars.join(\",\") : ctx.vars[0];\n    if (ctx.features & 4) {\n      params = ctx.vars.length > 1 || ctx.vars.length === 0 ? \"(\" + params + \")\" : params;\n      return \"(\" + params + \"=>(\" + body + \"))()\";\n    }\n    return \"(function(\" + params + \"){return \" + body + \"})()\";\n  }\n  if (isObject) {\n    return \"(\" + result + \")\";\n  }\n  return result;\n}\nfunction serialize(source, options) {\n  const ctx = createParserContext(options);\n  const [tree, rootID, isObject] = parseSync(ctx, source);\n  const serial = createSerializationContext(ctx);\n  const result = serializeTree(serial, tree);\n  return finalize(serial, rootID, isObject, result);\n}\nasync function serializeAsync(source, options) {\n  const ctx = createParserContext(options);\n  const [tree, rootID, isObject] = await parseAsync(ctx, source);\n  const serial = createSerializationContext(ctx);\n  const result = serializeTree(serial, tree);\n  return finalize(serial, rootID, isObject, result);\n}\nfunction deserialize(source) {\n  return (0, eval)(source);\n}\nfunction toJSON(source, options) {\n  const ctx = createParserContext(options);\n  const [tree, root, isObject] = parseSync(ctx, source);\n  return {\n    t: tree,\n    r: root,\n    i: isObject,\n    f: ctx.features,\n    m: Array.from(ctx.markedRefs)\n  };\n}\nasync function toJSONAsync(source, options) {\n  const ctx = createParserContext(options);\n  const [tree, root, isObject] = await parseAsync(ctx, source);\n  return {\n    t: tree,\n    r: root,\n    i: isObject,\n    f: ctx.features,\n    m: Array.from(ctx.markedRefs)\n  };\n}\nfunction compileJSON(source) {\n  const serial = createSerializationContext({\n    features: source.f,\n    markedRefs: source.m\n  });\n  const result = serializeTree(serial, source.t);\n  return finalize(serial, source.r, source.i, result);\n}\nfunction fromJSON(source) {\n  const serial = createSerializationContext({\n    features: source.f,\n    markedRefs: source.m\n  });\n  return deserializeTree(serial, source.t);\n}\nvar src_default = serialize;\nexport {\n  Feature,\n  compileJSON,\n  createReference,\n  src_default as default,\n  deserialize,\n  fromJSON,\n  serialize,\n  serializeAsync,\n  toJSON,\n  toJSONAsync\n};\n//# sourceMappingURL=seroval.js.map\n","start":1681089268660,"end":1681089268661,"order":"normal"}]}
