{"resolvedId":"D:/Files/Github/thaler/packages/thaler/dist/esm/development/client.mjs","transforms":[{"name":"__load__","result":"// client/index.ts\nimport { createReference, deserialize, toJSONAsync as toJSONAsync2 } from \"seroval\";\n\n// shared/error.ts\nvar ThalerError = class extends Error {\n  constructor(id) {\n    super(`function \"${id}\" threw an unhandled server-side error.`);\n  }\n};\n\n// shared/utils.ts\nimport { toJSONAsync } from \"seroval\";\nvar XThalerRequestType = \"X-Thaler-Request-Type\";\nfunction patchHeaders(init, type) {\n  if (init.headers) {\n    const header = new Headers(init.headers);\n    header.set(XThalerRequestType, type);\n    init.headers = header;\n  } else {\n    init.headers = {\n      [XThalerRequestType]: type\n    };\n  }\n}\nasync function serializeFunctionBody({ scope, value }) {\n  return JSON.stringify(await toJSONAsync({ scope: scope(), value }));\n}\nfunction toFormData(source) {\n  const formData = new FormData();\n  for (const [key, value] of Object.entries(source)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (typeof item === \"string\") {\n          formData.append(key, item);\n        } else {\n          formData.append(key, item, item.name);\n        }\n      }\n    } else if (typeof value === \"string\") {\n      formData.append(key, value);\n    } else {\n      formData.append(key, value, value.name);\n    }\n  }\n  return formData;\n}\nfunction toURLSearchParams(source) {\n  const search = new URLSearchParams();\n  for (const [key, value] of Object.entries(source)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        search.append(key, item);\n      }\n    } else {\n      search.append(key, value);\n    }\n  }\n  search.sort();\n  return search;\n}\n\n// client/index.ts\nfunction $$register(...[type, id]) {\n  return { type, id };\n}\nvar INTERCEPTORS = [];\nfunction interceptRequest(callback) {\n  INTERCEPTORS.push(callback);\n}\nasync function serverHandler(type, id, init) {\n  patchHeaders(init, type);\n  let root = new Request(id, init);\n  for (const intercept of INTERCEPTORS) {\n    root = await intercept(root);\n  }\n  const result = await fetch(root);\n  return result;\n}\nasync function postHandler(id, form, init = {}) {\n  return serverHandler(\"post\", id, {\n    ...init,\n    method: \"POST\",\n    body: toFormData(form)\n  });\n}\nasync function getHandler(id, search, init = {}) {\n  return serverHandler(\"get\", `${id}?${toURLSearchParams(search).toString()}`, {\n    ...init,\n    method: \"GET\"\n  });\n}\nasync function fnHandler(id, scope, value, init = {}) {\n  const response = await serverHandler(\"fn\", id, {\n    ...init,\n    method: \"POST\",\n    body: await serializeFunctionBody({ scope, value })\n  });\n  if (response.ok) {\n    return deserialize(await response.text());\n  }\n  throw new ThalerError(id);\n}\nasync function pureHandler(id, value, init = {}) {\n  const response = await serverHandler(\"pure\", id, {\n    ...init,\n    method: \"POST\",\n    body: JSON.stringify(await toJSONAsync2(value))\n  });\n  if (response.ok) {\n    return deserialize(await response.text());\n  }\n  throw new ThalerError(id);\n}\nfunction $$clone({ type, id }, scope) {\n  switch (type) {\n    case \"server\":\n      return Object.assign(serverHandler.bind(null, \"server\", id), {\n        type,\n        id\n      });\n    case \"post\":\n      return Object.assign(postHandler.bind(null, id), {\n        type,\n        id\n      });\n    case \"get\":\n      return Object.assign(getHandler.bind(null, id), {\n        type,\n        id\n      });\n    case \"fn\":\n      return Object.assign(fnHandler.bind(null, id, scope), {\n        type,\n        id\n      });\n    case \"pure\":\n      return Object.assign(pureHandler.bind(null, id), {\n        type,\n        id\n      });\n    default:\n      throw new Error(\"unknown registration type\");\n  }\n}\nfunction $$ref(id, value) {\n  return createReference(`thaler--${id}`, value);\n}\nexport {\n  $$clone,\n  $$ref,\n  $$register,\n  interceptRequest\n};\n                                   \n","start":1681089272995,"end":1681089272995},{"name":"vite:import-analysis","result":"// client/index.ts\nimport { createReference, deserialize, toJSONAsync as toJSONAsync2 } from \"/node_modules/.vite/deps/seroval.js?v=9590c33f\";\n\n// shared/error.ts\nvar ThalerError = class extends Error {\n  constructor(id) {\n    super(`function \"${id}\" threw an unhandled server-side error.`);\n  }\n};\n\n// shared/utils.ts\nimport { toJSONAsync } from \"/node_modules/.vite/deps/seroval.js?v=9590c33f\";\nvar XThalerRequestType = \"X-Thaler-Request-Type\";\nfunction patchHeaders(init, type) {\n  if (init.headers) {\n    const header = new Headers(init.headers);\n    header.set(XThalerRequestType, type);\n    init.headers = header;\n  } else {\n    init.headers = {\n      [XThalerRequestType]: type\n    };\n  }\n}\nasync function serializeFunctionBody({ scope, value }) {\n  return JSON.stringify(await toJSONAsync({ scope: scope(), value }));\n}\nfunction toFormData(source) {\n  const formData = new FormData();\n  for (const [key, value] of Object.entries(source)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (typeof item === \"string\") {\n          formData.append(key, item);\n        } else {\n          formData.append(key, item, item.name);\n        }\n      }\n    } else if (typeof value === \"string\") {\n      formData.append(key, value);\n    } else {\n      formData.append(key, value, value.name);\n    }\n  }\n  return formData;\n}\nfunction toURLSearchParams(source) {\n  const search = new URLSearchParams();\n  for (const [key, value] of Object.entries(source)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        search.append(key, item);\n      }\n    } else {\n      search.append(key, value);\n    }\n  }\n  search.sort();\n  return search;\n}\n\n// client/index.ts\nfunction $$register(...[type, id]) {\n  return { type, id };\n}\nvar INTERCEPTORS = [];\nfunction interceptRequest(callback) {\n  INTERCEPTORS.push(callback);\n}\nasync function serverHandler(type, id, init) {\n  patchHeaders(init, type);\n  let root = new Request(id, init);\n  for (const intercept of INTERCEPTORS) {\n    root = await intercept(root);\n  }\n  const result = await fetch(root);\n  return result;\n}\nasync function postHandler(id, form, init = {}) {\n  return serverHandler(\"post\", id, {\n    ...init,\n    method: \"POST\",\n    body: toFormData(form)\n  });\n}\nasync function getHandler(id, search, init = {}) {\n  return serverHandler(\"get\", `${id}?${toURLSearchParams(search).toString()}`, {\n    ...init,\n    method: \"GET\"\n  });\n}\nasync function fnHandler(id, scope, value, init = {}) {\n  const response = await serverHandler(\"fn\", id, {\n    ...init,\n    method: \"POST\",\n    body: await serializeFunctionBody({ scope, value })\n  });\n  if (response.ok) {\n    return deserialize(await response.text());\n  }\n  throw new ThalerError(id);\n}\nasync function pureHandler(id, value, init = {}) {\n  const response = await serverHandler(\"pure\", id, {\n    ...init,\n    method: \"POST\",\n    body: JSON.stringify(await toJSONAsync2(value))\n  });\n  if (response.ok) {\n    return deserialize(await response.text());\n  }\n  throw new ThalerError(id);\n}\nfunction $$clone({ type, id }, scope) {\n  switch (type) {\n    case \"server\":\n      return Object.assign(serverHandler.bind(null, \"server\", id), {\n        type,\n        id\n      });\n    case \"post\":\n      return Object.assign(postHandler.bind(null, id), {\n        type,\n        id\n      });\n    case \"get\":\n      return Object.assign(getHandler.bind(null, id), {\n        type,\n        id\n      });\n    case \"fn\":\n      return Object.assign(fnHandler.bind(null, id, scope), {\n        type,\n        id\n      });\n    case \"pure\":\n      return Object.assign(pureHandler.bind(null, id), {\n        type,\n        id\n      });\n    default:\n      throw new Error(\"unknown registration type\");\n  }\n}\nfunction $$ref(id, value) {\n  return createReference(`thaler--${id}`, value);\n}\nexport {\n  $$clone,\n  $$ref,\n  $$register,\n  interceptRequest\n};\n                                   \n","start":1681089272995,"end":1681089272996,"order":"normal"}]}
