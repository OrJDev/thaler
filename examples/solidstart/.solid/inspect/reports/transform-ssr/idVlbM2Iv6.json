{"resolvedId":"D:/Files/Github/thaler/packages/thaler/dist/esm/development/server.mjs","transforms":[{"name":"__load__","result":"// server/index.ts\nimport {\n  createReference,\n  fromJSON,\n  serializeAsync,\n  toJSONAsync as toJSONAsync2\n} from \"seroval\";\n\n// shared/utils.ts\nimport { toJSONAsync } from \"seroval\";\nvar XThalerRequestType = \"X-Thaler-Request-Type\";\nfunction patchHeaders(init, type) {\n  if (init.headers) {\n    const header = new Headers(init.headers);\n    header.set(XThalerRequestType, type);\n    init.headers = header;\n  } else {\n    init.headers = {\n      [XThalerRequestType]: type\n    };\n  }\n}\nasync function serializeFunctionBody({ scope, value }) {\n  return JSON.stringify(await toJSONAsync({ scope: scope(), value }));\n}\nfunction fromFormData(formData) {\n  const source = {};\n  formData.forEach((value, key) => {\n    if (key in source) {\n      const current = source[key];\n      if (Array.isArray(current)) {\n        current.push(value);\n      } else {\n        source[key] = [current, value];\n      }\n    } else {\n      source[key] = value;\n    }\n  });\n  return source;\n}\nfunction toFormData(source) {\n  const formData = new FormData();\n  for (const [key, value] of Object.entries(source)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (typeof item === \"string\") {\n          formData.append(key, item);\n        } else {\n          formData.append(key, item, item.name);\n        }\n      }\n    } else if (typeof value === \"string\") {\n      formData.append(key, value);\n    } else {\n      formData.append(key, value, value.name);\n    }\n  }\n  return formData;\n}\nfunction fromURLSearchParams(search) {\n  const source = {};\n  for (const [key, value] of search.entries()) {\n    if (key in source) {\n      const current = source[key];\n      if (Array.isArray(current)) {\n        current.push(value);\n      } else {\n        source[key] = [current, value];\n      }\n    } else {\n      source[key] = value;\n    }\n  }\n  return source;\n}\nfunction toURLSearchParams(source) {\n  const search = new URLSearchParams();\n  for (const [key, value] of Object.entries(source)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        search.append(key, item);\n      }\n    } else {\n      search.append(key, value);\n    }\n  }\n  search.sort();\n  return search;\n}\n\n// server/index.ts\nvar REGISTRATIONS = /* @__PURE__ */ new Map();\nfunction $$register(...registration) {\n  const url = new URL(registration[1]);\n  REGISTRATIONS.set(url.pathname, registration);\n  return registration;\n}\nasync function serverHandler(id, callback, init) {\n  patchHeaders(init, \"server\");\n  const request = new Request(id, init);\n  return callback(request);\n}\nasync function actionHandler(id, callback, formData, init = {}) {\n  patchHeaders(init, \"post\");\n  const request = new Request(id, {\n    ...init,\n    method: \"POST\",\n    body: toFormData(formData)\n  });\n  return callback(formData, request);\n}\nasync function getHandler(id, callback, search, init = {}) {\n  patchHeaders(init, \"get\");\n  const request = new Request(`${id}?${toURLSearchParams(search).toString()}`, {\n    ...init,\n    method: \"GET\"\n  });\n  return callback(search, request);\n}\nvar SCOPE;\nfunction runWithScope(scope, callback) {\n  const parent = SCOPE;\n  SCOPE = scope();\n  try {\n    console.log(SCOPE);\n    return callback();\n  } finally {\n    SCOPE = parent;\n  }\n}\nasync function fnHandler(id, callback, scope, value, init = {}) {\n  patchHeaders(init, \"fn\");\n  const request = new Request(id, {\n    ...init,\n    method: \"POST\",\n    body: await serializeFunctionBody({ scope, value })\n  });\n  return runWithScope(scope, () => callback(value, request));\n}\nasync function pureHandler(id, callback, value, init = {}) {\n  patchHeaders(init, \"fn\");\n  const request = new Request(id, {\n    ...init,\n    method: \"POST\",\n    body: JSON.stringify(await toJSONAsync2(value))\n  });\n  return callback(value, request);\n}\nfunction $$scope() {\n  console.log(SCOPE);\n  return SCOPE;\n}\nfunction $$clone([type, id, callback], scope) {\n  switch (type) {\n    case \"server\":\n      return Object.assign(serverHandler.bind(null, id, callback), {\n        type,\n        id\n      });\n    case \"post\":\n      return Object.assign(actionHandler.bind(null, id, callback), {\n        type,\n        id\n      });\n    case \"get\":\n      return Object.assign(getHandler.bind(null, id, callback), {\n        type,\n        id\n      });\n    case \"fn\":\n      return Object.assign(fnHandler.bind(null, id, callback, scope), {\n        type,\n        id\n      });\n    case \"pure\":\n      return Object.assign(pureHandler.bind(null, id, callback), {\n        type,\n        id\n      });\n    default:\n      throw new Error(\"unknown registration type\");\n  }\n}\nasync function handleRequest(request) {\n  const url = new URL(request.url);\n  const registration = REGISTRATIONS.get(url.pathname);\n  if (registration) {\n    const [type, id, callback] = registration;\n    try {\n      switch (type) {\n        case \"server\":\n          return await callback(request);\n        case \"post\":\n          return await callback(\n            fromFormData(await request.formData()),\n            request\n          );\n        case \"get\":\n          return await callback(\n            fromURLSearchParams(url.searchParams),\n            request\n          );\n        case \"fn\": {\n          const { scope, value } = fromJSON(await request.json());\n          const result = await runWithScope(() => scope, () => callback(value, request));\n          const serialized = await serializeAsync(result);\n          return new Response(serialized, {\n            status: 200,\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            }\n          });\n        }\n        case \"pure\": {\n          const value = fromJSON(await request.json());\n          const result = await callback(value, request);\n          const serialized = await serializeAsync(result);\n          return new Response(serialized, {\n            status: 200,\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            }\n          });\n        }\n        default:\n          throw new Error(\"unexpected type\");\n      }\n    } catch (error) {\n      if (true) {\n        console.error(error);\n      }\n      return new Response(`function \"${id}\" threw an unhandled server-side error.`, {\n        status: 500\n      });\n    }\n  }\n  return void 0;\n}\nfunction $$ref(id, value) {\n  return createReference(`thaler--${id}`, value);\n}\nexport {\n  $$clone,\n  $$ref,\n  $$register,\n  $$scope,\n  handleRequest\n};\n                                   \n","start":1681089269628,"end":1681089269628},{"name":"vite:define","result":"// server/index.ts\nimport {\n  createReference,\n  fromJSON,\n  serializeAsync,\n  toJSONAsync as toJSONAsync2\n} from \"seroval\";\n\n// shared/utils.ts\nimport { toJSONAsync } from \"seroval\";\nvar XThalerRequestType = \"X-Thaler-Request-Type\";\nfunction patchHeaders(init, type) {\n  if (init.headers) {\n    const header = new Headers(init.headers);\n    header.set(XThalerRequestType, type);\n    init.headers = header;\n  } else {\n    init.headers = {\n      [XThalerRequestType]: type\n    };\n  }\n}\nasync function serializeFunctionBody({ scope, value }) {\n  return JSON.stringify(await toJSONAsync({ scope: scope(), value }));\n}\nfunction fromFormData(formData) {\n  const source = {};\n  formData.forEach((value, key) => {\n    if (key in source) {\n      const current = source[key];\n      if (Array.isArray(current)) {\n        current.push(value);\n      } else {\n        source[key] = [current, value];\n      }\n    } else {\n      source[key] = value;\n    }\n  });\n  return source;\n}\nfunction toFormData(source) {\n  const formData = new FormData();\n  for (const [key, value] of Object.entries(source)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (typeof item === \"string\") {\n          formData.append(key, item);\n        } else {\n          formData.append(key, item, item.name);\n        }\n      }\n    } else if (typeof value === \"string\") {\n      formData.append(key, value);\n    } else {\n      formData.append(key, value, value.name);\n    }\n  }\n  return formData;\n}\nfunction fromURLSearchParams(search) {\n  const source = {};\n  for (const [key, value] of search.entries()) {\n    if (key in source) {\n      const current = source[key];\n      if (Array.isArray(current)) {\n        current.push(value);\n      } else {\n        source[key] = [current, value];\n      }\n    } else {\n      source[key] = value;\n    }\n  }\n  return source;\n}\nfunction toURLSearchParams(source) {\n  const search = new URLSearchParams();\n  for (const [key, value] of Object.entries(source)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        search.append(key, item);\n      }\n    } else {\n      search.append(key, value);\n    }\n  }\n  search.sort();\n  return search;\n}\n\n// server/index.ts\nvar REGISTRATIONS = /* @__PURE__ */ new Map();\nfunction $$register(...registration) {\n  const url = new URL(registration[1]);\n  REGISTRATIONS.set(url.pathname, registration);\n  return registration;\n}\nasync function serverHandler(id, callback, init) {\n  patchHeaders(init, \"server\");\n  const request = new Request(id, init);\n  return callback(request);\n}\nasync function actionHandler(id, callback, formData, init = {}) {\n  patchHeaders(init, \"post\");\n  const request = new Request(id, {\n    ...init,\n    method: \"POST\",\n    body: toFormData(formData)\n  });\n  return callback(formData, request);\n}\nasync function getHandler(id, callback, search, init = {}) {\n  patchHeaders(init, \"get\");\n  const request = new Request(`${id}?${toURLSearchParams(search).toString()}`, {\n    ...init,\n    method: \"GET\"\n  });\n  return callback(search, request);\n}\nvar SCOPE;\nfunction runWithScope(scope, callback) {\n  const parent = SCOPE;\n  SCOPE = scope();\n  try {\n    console.log(SCOPE);\n    return callback();\n  } finally {\n    SCOPE = parent;\n  }\n}\nasync function fnHandler(id, callback, scope, value, init = {}) {\n  patchHeaders(init, \"fn\");\n  const request = new Request(id, {\n    ...init,\n    method: \"POST\",\n    body: await serializeFunctionBody({ scope, value })\n  });\n  return runWithScope(scope, () => callback(value, request));\n}\nasync function pureHandler(id, callback, value, init = {}) {\n  patchHeaders(init, \"fn\");\n  const request = new Request(id, {\n    ...init,\n    method: \"POST\",\n    body: JSON.stringify(await toJSONAsync2(value))\n  });\n  return callback(value, request);\n}\nfunction $$scope() {\n  console.log(SCOPE);\n  return SCOPE;\n}\nfunction $$clone([type, id, callback], scope) {\n  switch (type) {\n    case \"server\":\n      return Object.assign(serverHandler.bind(null, id, callback), {\n        type,\n        id\n      });\n    case \"post\":\n      return Object.assign(actionHandler.bind(null, id, callback), {\n        type,\n        id\n      });\n    case \"get\":\n      return Object.assign(getHandler.bind(null, id, callback), {\n        type,\n        id\n      });\n    case \"fn\":\n      return Object.assign(fnHandler.bind(null, id, callback, scope), {\n        type,\n        id\n      });\n    case \"pure\":\n      return Object.assign(pureHandler.bind(null, id, callback), {\n        type,\n        id\n      });\n    default:\n      throw new Error(\"unknown registration type\");\n  }\n}\nasync function handleRequest(request) {\n  const url = new URL(request.url);\n  const registration = REGISTRATIONS.get(url.pathname);\n  if (registration) {\n    const [type, id, callback] = registration;\n    try {\n      switch (type) {\n        case \"server\":\n          return await callback(request);\n        case \"post\":\n          return await callback(\n            fromFormData(await request.formData()),\n            request\n          );\n        case \"get\":\n          return await callback(\n            fromURLSearchParams(url.searchParams),\n            request\n          );\n        case \"fn\": {\n          const { scope, value } = fromJSON(await request.json());\n          const result = await runWithScope(() => scope, () => callback(value, request));\n          const serialized = await serializeAsync(result);\n          return new Response(serialized, {\n            status: 200,\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            }\n          });\n        }\n        case \"pure\": {\n          const value = fromJSON(await request.json());\n          const result = await callback(value, request);\n          const serialized = await serializeAsync(result);\n          return new Response(serialized, {\n            status: 200,\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            }\n          });\n        }\n        default:\n          throw new Error(\"unexpected type\");\n      }\n    } catch (error) {\n      if (true) {\n        console.error(error);\n      }\n      return new Response(`function \"${id}\" threw an unhandled server-side error.`, {\n        status: 500\n      });\n    }\n  }\n  return void 0;\n}\nfunction $$ref(id, value) {\n  return createReference(`thaler--${id}`, value);\n}\nexport {\n  $$clone,\n  $$ref,\n  $$register,\n  $$scope,\n  handleRequest\n};\n                                   \n","start":1681089269628,"end":1681089269628,"order":"normal"},{"name":"vite:import-analysis","result":"// server/index.ts\nimport {\n  createReference,\n  fromJSON,\n  serializeAsync,\n  toJSONAsync as toJSONAsync2\n} from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/seroval@0.7.0/node_modules/seroval/dist/esm/development/index.mjs\";\n\n// shared/utils.ts\nimport { toJSONAsync } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/seroval@0.7.0/node_modules/seroval/dist/esm/development/index.mjs\";\nvar XThalerRequestType = \"X-Thaler-Request-Type\";\nfunction patchHeaders(init, type) {\n  if (init.headers) {\n    const header = new Headers(init.headers);\n    header.set(XThalerRequestType, type);\n    init.headers = header;\n  } else {\n    init.headers = {\n      [XThalerRequestType]: type\n    };\n  }\n}\nasync function serializeFunctionBody({ scope, value }) {\n  return JSON.stringify(await toJSONAsync({ scope: scope(), value }));\n}\nfunction fromFormData(formData) {\n  const source = {};\n  formData.forEach((value, key) => {\n    if (key in source) {\n      const current = source[key];\n      if (Array.isArray(current)) {\n        current.push(value);\n      } else {\n        source[key] = [current, value];\n      }\n    } else {\n      source[key] = value;\n    }\n  });\n  return source;\n}\nfunction toFormData(source) {\n  const formData = new FormData();\n  for (const [key, value] of Object.entries(source)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (typeof item === \"string\") {\n          formData.append(key, item);\n        } else {\n          formData.append(key, item, item.name);\n        }\n      }\n    } else if (typeof value === \"string\") {\n      formData.append(key, value);\n    } else {\n      formData.append(key, value, value.name);\n    }\n  }\n  return formData;\n}\nfunction fromURLSearchParams(search) {\n  const source = {};\n  for (const [key, value] of search.entries()) {\n    if (key in source) {\n      const current = source[key];\n      if (Array.isArray(current)) {\n        current.push(value);\n      } else {\n        source[key] = [current, value];\n      }\n    } else {\n      source[key] = value;\n    }\n  }\n  return source;\n}\nfunction toURLSearchParams(source) {\n  const search = new URLSearchParams();\n  for (const [key, value] of Object.entries(source)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        search.append(key, item);\n      }\n    } else {\n      search.append(key, value);\n    }\n  }\n  search.sort();\n  return search;\n}\n\n// server/index.ts\nvar REGISTRATIONS = /* @__PURE__ */ new Map();\nfunction $$register(...registration) {\n  const url = new URL(registration[1]);\n  REGISTRATIONS.set(url.pathname, registration);\n  return registration;\n}\nasync function serverHandler(id, callback, init) {\n  patchHeaders(init, \"server\");\n  const request = new Request(id, init);\n  return callback(request);\n}\nasync function actionHandler(id, callback, formData, init = {}) {\n  patchHeaders(init, \"post\");\n  const request = new Request(id, {\n    ...init,\n    method: \"POST\",\n    body: toFormData(formData)\n  });\n  return callback(formData, request);\n}\nasync function getHandler(id, callback, search, init = {}) {\n  patchHeaders(init, \"get\");\n  const request = new Request(`${id}?${toURLSearchParams(search).toString()}`, {\n    ...init,\n    method: \"GET\"\n  });\n  return callback(search, request);\n}\nvar SCOPE;\nfunction runWithScope(scope, callback) {\n  const parent = SCOPE;\n  SCOPE = scope();\n  try {\n    console.log(SCOPE);\n    return callback();\n  } finally {\n    SCOPE = parent;\n  }\n}\nasync function fnHandler(id, callback, scope, value, init = {}) {\n  patchHeaders(init, \"fn\");\n  const request = new Request(id, {\n    ...init,\n    method: \"POST\",\n    body: await serializeFunctionBody({ scope, value })\n  });\n  return runWithScope(scope, () => callback(value, request));\n}\nasync function pureHandler(id, callback, value, init = {}) {\n  patchHeaders(init, \"fn\");\n  const request = new Request(id, {\n    ...init,\n    method: \"POST\",\n    body: JSON.stringify(await toJSONAsync2(value))\n  });\n  return callback(value, request);\n}\nfunction $$scope() {\n  console.log(SCOPE);\n  return SCOPE;\n}\nfunction $$clone([type, id, callback], scope) {\n  switch (type) {\n    case \"server\":\n      return Object.assign(serverHandler.bind(null, id, callback), {\n        type,\n        id\n      });\n    case \"post\":\n      return Object.assign(actionHandler.bind(null, id, callback), {\n        type,\n        id\n      });\n    case \"get\":\n      return Object.assign(getHandler.bind(null, id, callback), {\n        type,\n        id\n      });\n    case \"fn\":\n      return Object.assign(fnHandler.bind(null, id, callback, scope), {\n        type,\n        id\n      });\n    case \"pure\":\n      return Object.assign(pureHandler.bind(null, id, callback), {\n        type,\n        id\n      });\n    default:\n      throw new Error(\"unknown registration type\");\n  }\n}\nasync function handleRequest(request) {\n  const url = new URL(request.url);\n  const registration = REGISTRATIONS.get(url.pathname);\n  if (registration) {\n    const [type, id, callback] = registration;\n    try {\n      switch (type) {\n        case \"server\":\n          return await callback(request);\n        case \"post\":\n          return await callback(\n            fromFormData(await request.formData()),\n            request\n          );\n        case \"get\":\n          return await callback(\n            fromURLSearchParams(url.searchParams),\n            request\n          );\n        case \"fn\": {\n          const { scope, value } = fromJSON(await request.json());\n          const result = await runWithScope(() => scope, () => callback(value, request));\n          const serialized = await serializeAsync(result);\n          return new Response(serialized, {\n            status: 200,\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            }\n          });\n        }\n        case \"pure\": {\n          const value = fromJSON(await request.json());\n          const result = await callback(value, request);\n          const serialized = await serializeAsync(result);\n          return new Response(serialized, {\n            status: 200,\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            }\n          });\n        }\n        default:\n          throw new Error(\"unexpected type\");\n      }\n    } catch (error) {\n      if (true) {\n        console.error(error);\n      }\n      return new Response(`function \"${id}\" threw an unhandled server-side error.`, {\n        status: 500\n      });\n    }\n  }\n  return void 0;\n}\nfunction $$ref(id, value) {\n  return createReference(`thaler--${id}`, value);\n}\nexport {\n  $$clone,\n  $$ref,\n  $$register,\n  $$scope,\n  handleRequest\n};\n                                   \n","start":1681089269629,"end":1681089269630,"order":"normal"}]}
